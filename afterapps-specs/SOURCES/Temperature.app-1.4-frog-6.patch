--- Makefile	2001-06-25 18:03:07.000000000 +0200
+++ Makefile	2006-02-24 21:08:06.000000000 +0100
@@ -1,35 +1,32 @@
-#
-# Temperature.app Makefile
-#
+CC              = g++
+CXXFLAGS	+= -I.. -I/usr/include -I/usr/include/freetype2 -DHAVE_XFT -Wall
+LIBS            = -L/usr/lib64 -L/usr/lib -lXpm -lX11 -lpthread -lXft -lXext -lXext
 
-DESTDIR =
-GNUSTEP_BINDIR = /usr/local/GNUstep/Apps/Temperature.app
-X11_BINDIR = /usr/X11R6/bin
+PREFIX          = /usr
+INSTALL         = /usr/bin/install -c
+DESTDIR         =
 
-CXX=c++
-CXXFLAGS += -Wall -pedantic -fno-rtti -fno-exceptions -O2 -I/usr/X11R6/include
-LDFLAGS += -L/usr/X11R6/lib -lXpm -lXext -lX11
+SRCS	= $(wildcard *.cc)
+OBJS 	= $(patsubst %.cc,%.o,$(SRCS))
 
-OBJECTS = Main.o Temperature.o Xpm.o
+all::Temperature.app
 
-all: Temperature.app
+Temperature.app:dep $(OBJS)
+	$(CC) $(CXXFLAGS) -o $@ $(OBJS) $(LIBS)
 
-Temperature.app: $(OBJECTS)
-	$(CXX) $(OBJECTS) -o $@ $(LDFLAGS)
+install: Temperature.app
+	$(INSTALL) -m 755 $< $(DESTDIR)$(PREFIX)/bin
 
-.PHONY:	install install-gnustep install-x11 clean
+clean:: 
+	rm -f $(OBJS)
+	rm -f Temperature.app
 
-install: install-gnustep
+dep: $(SRCS)
+	$(CC) $(CXXFLAGS) -MM $< > .depend
 
-install-gnustep: all
-	install -d  $(DESTDIR)$(GNUSTEP_BINDIR)
-	install -m 0755 Temperature.app $(DESTDIR)$(GNUSTEP_BINDIR)/Temperature
+ifeq (.depend,$(wildcard .depend))
+include .depend
+endif
 
-install-x11: all
-	install -d  $(DESTDIR)$(X11_BINDIR)
-	install -m 0755 Temperature.app $(DESTDIR)$(X11_BINDIR)/Temperature.app
-
-clean:
-	rm -f *~ *.o
-
-# End of file
+clean::
+	rm -f .depend
--- Temperature.cc	2002-04-05 17:44:09.000000000 -0600
+++ Temperature.cc	2012-02-14 09:31:46.000000000 -0600
@@ -2,6 +2,7 @@
 //  Temperature.app
 // 
 //  Copyright (c) 2000-2002 Per Liden
+//  Copyright (c) 2004 Sven Schaepe
 // 
 //  This program is free software; you can redistribute it and/or modify
 //  it under the terms of the GNU General Public License as published by
@@ -20,24 +21,20 @@
 //
 
 #include <X11/Xlib.h>
-#include <iostream.h>
-#include <fstream.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <unistd.h>
-#include <signal.h>
-#include <errno.h>
 #include <sys/types.h>
 #include <sys/wait.h>
-#include <math.h>
-#include <time.h>
-#include "Xpm.h"
+#include <iostream>
+#include <fstream>
+#include <cstdlib>
+#include <cstdio>
+#include <string>
+#include <unistd.h>
+#include <csignal>
+#include <cerrno>
+#include <cmath>
+#include <ctime>
 #include "Temperature.h"
 
-#include "pixmaps/main.xpm"
-#include "pixmaps/redlight.xpm"
-
 volatile static ChildStatus childStatus;
 
 static void catchBrokenPipe(int sig) 
@@ -61,28 +58,34 @@
    }
 
    if (childStatus == ChildError) {
-      cerr << APPNAME << ": could not fetch temperature (wget failed), try option -V for more information" << endl;
+      std::cerr << APPNAME << ": could not fetch temperature (wget failed), try option -V for more information" << std::endl;
    }
 }
 
 Temperature::Temperature(int argc, char** argv) 
 {
-   XClassHint classHint;
-   XSizeHints sizeHints;
-   XWMHints   wmHints;
-   Atom       deleteWindow;
-   Xpm*       image;
    char*      displayName = NULL;
 
    mInstanceName = INSTANCENAME;
    mStationId = 0;
+   mPressure[0] = 0;
    mTemperature[0] = 0;
    mTime[0] = 0;
    mTimeDiff = 0.0;
    mFahrenheit = false;
+   mMPH = false;
    mShowTime = false;
+   mShowPressure = false;
+   mShowWind = false;
+   mShowTemperatureWindChill = false;
    mTime12HourFormat = false;
    mVerbose = false;
+   _smallFontString="arial:pixelsize=7:weight=bold";
+   _mediumFontString="arial:pixelsize=9:weight=bold";
+   _bigFontString="arial:pixelsize=16:weight=bold";
+   _smallFont=NULL;
+   _mediumFont=NULL;
+   _bigFont=NULL;
 
    // Parse command line
    if (argc>1) {
@@ -106,6 +109,31 @@
             mFahrenheit = true;
          }
 
+         // WindChill
+         else if (!strcmp(argv[i], "-c")) {
+            mShowTemperatureWindChill = true;
+         }
+
+         // Pressure
+         else if (!strcmp(argv[i], "-p")) {
+            mShowPressure = true;
+         }
+
+         // Wind
+         else if (!strcmp(argv[i], "-w")) {
+            mShowWind = true;
+            checkArgument(argv, argc, i);
+            if (!strcmp(argv[i+1], "MPH")) {
+               mMPH = true;
+	    } else if (!strcmp(argv[i+1], "KMH")) {
+               mMPH = false;
+	    } else {
+               std::cerr << APPNAME << ": unknown Speed unit, use MPH or KMH" << std::endl;
+	       exit(0);
+	    }
+            i++;
+         }
+
          // Time
          else if (!strcmp(argv[i], "-t")) {
             mShowTime = true;
@@ -113,7 +141,7 @@
             if (!strcmp(argv[i+1], "12")) {
                mTime12HourFormat = true;
             } else if (strcmp(argv[i+1], "24")) {
-               cerr << APPNAME << ": unknown time format, use 12 or 24" << endl;
+               std::cerr << APPNAME << ": unknown time format, use 12 or 24" << std::endl;
                exit(0);
             }
             i++;
@@ -133,7 +161,7 @@
 
          // Version
          else if (!strcmp(argv[i], "-v")) {
-            cerr << APPNAME << " version " << VERSION << endl;
+            std::cerr << APPNAME << " version " << VERSION << std::endl;
             exit(0);
          }
 
@@ -145,7 +173,7 @@
 
          // Unknown option
          else {
-            cerr << APPNAME << ": invalid option '" << argv[i] << "'" << endl;
+            std::cerr << APPNAME << ": invalid option '" << argv[i] << "'" << std::endl;
             tryHelp(argv[0]);
             exit(0);
          }
@@ -153,120 +181,73 @@
    }
 
    if (mStationId == 0) {
-      cerr << APPNAME << ": you must supply a station id using -s <id>" << endl;
+      std::cerr << APPNAME << ": you must supply a station id using -s <id>" << std::endl;
       tryHelp(argv[0]);
       exit(0);
    }
 
+
    // Open display
    if ((mDisplay = XOpenDisplay(displayName)) == NULL) {
-      cerr << APPNAME << ": could not open display " << displayName << endl;
+      std::cerr << APPNAME << ": could not open display " << displayName << std::endl;
       exit(0);
    }
- 
-   // Get root window
-   mRoot = RootWindow(mDisplay, DefaultScreen(mDisplay));
-
-   // Create windows
-   mAppWin = XCreateSimpleWindow(mDisplay, mRoot, 1, 1, 64, 64, 0, 0, 0);
-   mIconWin = XCreateSimpleWindow(mDisplay, mAppWin, 0, 0, 64, 64, 0, 0, 0);
-        
-   // Set classhint
-   classHint.res_name =  mInstanceName;
-   classHint.res_class = CLASSNAME;
-   XSetClassHint(mDisplay, mAppWin, &classHint);
-
-   // Create delete atom
-   deleteWindow = XInternAtom(mDisplay, "WM_DELETE_WINDOW", False);
-   XSetWMProtocols(mDisplay, mAppWin, &deleteWindow, 1);
-   XSetWMProtocols(mDisplay, mIconWin, &deleteWindow, 1);
-
-   // Set windowname
-   XStoreName(mDisplay, mAppWin, APPNAME);
-   XSetIconName(mDisplay, mAppWin, APPNAME);
-
-   // Set sizehints
-   sizeHints.flags= USPosition;
-   sizeHints.x = 0;
-   sizeHints.y = 0;
-   XSetWMNormalHints(mDisplay, mAppWin, &sizeHints);
-
-   // Set wmhints
-   wmHints.initial_state = WithdrawnState;
-   wmHints.icon_window = mIconWin;
-   wmHints.icon_x = 0;
-   wmHints.icon_y = 0;
-   wmHints.window_group = mAppWin;
-   wmHints.flags = StateHint | IconWindowHint | IconPositionHint | WindowGroupHint;
-   XSetWMHints(mDisplay, mAppWin, &wmHints);
-
-   // Set command
-   XSetCommand(mDisplay, mAppWin, argv, argc);
-
-   // Set background image
-   image = new Xpm(mDisplay, mRoot, main_xpm);
-   image->setWindowPixmapShaped(mIconWin);
-   delete image;
-
-   // Create status led
-   mStatusLed = XCreateSimpleWindow(mDisplay, mIconWin, LED_X, LED_Y, 3, 2, 0, 0, 0);
-   image = new Xpm(mDisplay, mRoot, redlight_xpm);
-   image->setWindowPixmap(mStatusLed);
-   delete image;
-
-   XMapWindow(mDisplay, mIconWin);
-   XMapWindow(mDisplay, mAppWin);
-   XSync(mDisplay, False);
-
-   // Catch broker pipe signal
-   signal(SIGPIPE, catchBrokenPipe);
-
-   // Catch child exit signal
-   signal(SIGCHLD, catchChildExit);
+    _dockapp=new Dockapp();
+    _dockapp->init(mDisplay,APPNAME);
+    _dockapp->setAttribute("color",0xffffffff);
+}
+
+Temperature::~Temperature() 
+{
+    if(_smallFont) {
+	XftFontClose(mDisplay,_smallFont);
+    }
+    if(_mediumFont) {
+	XftFontClose(mDisplay,_mediumFont);
+    }
+    if(_bigFont) {
+	XftFontClose(mDisplay,_bigFont);
+    }
 }
 
 void Temperature::tryHelp(char* appname)
 {
-   cerr << endl << "Try `" << appname << " --help' for more information" << endl;
+   std::cerr << std::endl << "Try `" << appname << " --help' for more information" << std::endl;
 }
 
 void Temperature::showHelp() 
 {
-   cerr << APPNAME << " Copyright (c) 2000-2002 by Per Liden (per@fukt.bth.se)" << endl << endl
-        << "options:" << endl
-        << " -s <id>         set station id (ICAO Location Indicator)" << endl
-        << " -t 12|24        display time of temperature observation (12 or 24 hour format)" << endl
-        << " -f              display degrees in Fahrenheit" << endl
-        << " -V              display verbose messages from wget" << endl
-        << " -n <name>       set client instance name" << endl
-        << " -d <disp>       set display" << endl
-        << " -v              print version and exit" << endl
-        << " -h, --help      display this help text and exit" << endl 
-        << endl
-        << "You must supply the ICAO Location Indicator (a 4-character string)" << endl
-        << "of a weather station near you. You can search for a station on" << endl
-        << "this site: http://www.nws.noaa.gov/oso/siteloc.shtml" << endl;
+   std::cerr << APPNAME << std::endl
+        << "\t Copyright (c) 2000-2002 by Per Liden (per@fukt.bth.se)" << std::endl 
+        << "\t Copyright (c) 2006 by Sven Schaepe (schaepe@web.de)" << std::endl << std::endl
+
+        << "options:" << std::endl
+        << " -s <id>         set station id (ICAO Location Indicator)" << std::endl
+        << " -t 12|24        display time of temperature observation (12 or 24 hour format)" << std::endl
+        << " -w MPH|KMH      display Wind" << std::endl
+        << " -p              display pressure in hPa" << std::endl
+        << " -c              display windchill temperature" << std::endl
+        << " -f              display degrees in Fahrenheit" << std::endl
+        << " -V              display verbose messages from wget" << std::endl
+        << " -n <name>       set client instance name" << std::endl
+        << " -d <disp>       set display" << std::endl
+        << " -v              print version and exit" << std::endl
+        << " -h, --help      display this help text and exit" << std::endl 
+        << std::endl
+        << "You must supply the ICAO Location Indicator (a 4-character string)" << std::endl
+        << "of a weather station near you. You can search for a station on" << std::endl
+        << "this site: http://www.nws.noaa.gov/tg/siteloc.shtml" << std::endl;
 }
 
 void Temperature::checkArgument(char** argv, int argc, int index)
 {
    if (argc-1 < index+1) {
-      cerr << APPNAME << ": option '" << argv[index] << "' requires an argument" << endl;
+      std::cerr << APPNAME << ": option '" << argv[index] << "' requires an argument" << std::endl;
       tryHelp(argv[0]);
       exit(0);
    }
 }
 
-void Temperature::showLed(bool show)
-{
-   if (show) {
-      XMapWindow(mDisplay, mStatusLed);
-   } else {
-      XUnmapWindow(mDisplay, mStatusLed);
-   }
-   XSync(mDisplay, False);
-}
-
 void Temperature::calcTimeDiff()
 {
    struct tm* t;
@@ -333,7 +314,19 @@
    sprintf(mTime, "%d:%.2d", hour, min);
 }
 
-bool Temperature::updateTemperture(ifstream& file)
+std::string Temperature::windRose(int angle)
+{
+    if(angle==-1) {
+	return "";
+    }
+    double resolution=360.0/16.0;
+    char *from[]={"N","NNE","NE","ENE","E","ESE","SE","SSE","S","SSW","SW","WSW","W","WNW","NW","NNW"};
+    angle%=360;
+    double dAngle=double(angle);
+    int index=(int)rint(dAngle/resolution);
+    return (from[index%16]);
+}
+bool Temperature::updateTemperture(std::ifstream& file)
 {
    const int MAX_LINE = 1024;
    char buffer[MAX_LINE];
@@ -351,42 +344,182 @@
       setTime(time);
    }
    
-   // Find temperature
+    mTemperatureWindChill[0]='\0'; 
    while (!file.eof()) {
-      file >> buffer;
-      if (!strcmp(buffer, "Temperature:")) {
-         file >> buffer;
-         if (buffer && strlen(buffer) < 5) {
-            char* unit;
-            if (mFahrenheit) {
-               strcpy(mTemperature, buffer);
-               unit = " °F";
-            } else {
-               sprintf(mTemperature, "%d", (int)rint((atoi(buffer) - 32) / 1.8));
-               unit = " °C";
-            }
-            
-            Xpm* image = new Xpm(mDisplay, mRoot, main_xpm);
-            if (mShowTime) {
-               if (mTime12HourFormat) {
-                  image->drawComposedString(TIME_POS, TIME_FONT, mTime, AMPM_FONT, mTimeAMPM);
-               } else {
-                  image->drawString(TIME_POS, TIME_FONT, mTime);
-               }
-               image->drawComposedString(TEMP_WITH_TIME_POS, TEMP_FONT, mTemperature, UNIT_FONT, unit);
-            } else {
-               image->drawComposedString(TEMP_POS, TEMP_FONT, mTemperature, UNIT_FONT, unit);
-            }
-            image->setWindowPixmap(mIconWin);
-            delete image;
-            XSync(mDisplay, False);
-            return true;
-         }
+      std::string line;
+      getline(file,line);
+      std::string::size_type wordBegin,wordSize=line.find(" ");
+      if(wordSize>line.size()) {
+	wordSize=std::string::npos;
+      }
+      std::string substr=line.substr(0,wordSize);
+      if (!strcmp(substr.c_str(),"Wind:") && mShowWind) {
+	  wordBegin=wordSize+1;
+	  wordSize=line.find("degrees)",wordBegin);
+	  int angle=-1;
+	  if(wordSize<=line.size()) {
+	      wordSize=line.find("(",wordBegin);
+	      if(wordSize>line.size()) {
+		wordSize=std::string::npos;
+	      }
+	      wordBegin=wordSize+1;
+	      wordSize=line.find(" ",wordBegin);
+	      if(wordSize>line.size()) {
+		wordSize=std::string::npos;
+	      }
+	      substr=line.substr(wordBegin,wordSize-wordBegin);
+	      sscanf(substr.c_str(),"%d",&angle);
+	      wordBegin=wordSize+1;
+	  }
+	  wordSize=line.find("KT)",wordBegin);
+	  int speed=0;
+	  if(wordSize<=line.size()) {
+	      wordSize=line.find("(",wordBegin);
+	      if(wordSize>line.size()) {
+		wordSize=std::string::npos;
+	      }
+	      wordBegin=wordSize+1;
+	      wordSize=line.find(" ",wordBegin);
+	      if(wordSize>line.size()) {
+		wordSize=std::string::npos;
+	      }
+	      substr=line.substr(wordBegin,wordSize-wordBegin);
+	      sscanf(substr.c_str(),"%d",&speed);
+	  }
+	  if(mMPH) {
+	      snprintf(mWind,sizeof(mWind),"%s %0.1f",windRose(angle).c_str(),0.5144444/0.44704 * (double)speed);
+	      strncpy(mWindUnit," MPH",sizeof(mWindUnit));
+	  } else {
+	      snprintf(mWind,sizeof(mWind),"%s %0.1f",windRose(angle).c_str(),0.5144444/0.2777778 * (double)speed);
+	      strncpy(mWindUnit," kmh",sizeof(mWindUnit));
+	  }
+      } else if (!strcmp(substr.c_str(),"Pressure") && mShowPressure) {
+	  wordBegin=wordSize+1;
+	  wordSize=line.find(" ",wordBegin);
+	  if(wordSize>line.size()) {
+	    wordSize=std::string::npos;
+	  }
+	  substr=line.substr(wordBegin,wordSize-wordBegin);
+	  if (!strcmp(substr.c_str(),"(altimeter):")) {
+	      wordBegin=wordSize+1;
+	      wordSize=line.find(" ",wordBegin);
+	      if(wordSize>line.size()) {
+		wordSize=std::string::npos;
+	      }
+	      substr=line.substr(wordBegin,wordSize-wordBegin);
+	      double pressure;
+	      sscanf(substr.c_str(),"%lf",&pressure);
+	      snprintf(mPressure,sizeof(mPressure),"%d", (int)rint(pressure*33.85));
+	      strncpy(mPressureUnit," hPa",sizeof(mPressureUnit));
+	 }
+      } else if (!strcmp(substr.c_str(),"Windchill:") && mShowTemperatureWindChill) {
+	  wordBegin=wordSize+1;
+	  wordSize=line.find(" ",wordBegin);
+	  if(wordSize>line.size()) {
+	    wordSize=std::string::npos;
+	  }
+	  substr=line.substr(wordBegin,wordSize-wordBegin);
+	  strncpy(mTemperatureWindChill, substr.c_str(),sizeof(mTemperatureWindChill));
+	  if (!mFahrenheit) {
+	    snprintf(mTemperatureWindChill,sizeof(mTemperatureWindChill), "%d", (int)rint((atoi(substr.c_str()) - 32) / 1.8));
+	  }
+      } else if (!strcmp(substr.c_str(),"Temperature:")) {
+	  wordBegin=wordSize+1;
+	  wordSize=line.find(" ",wordBegin);
+	  if(wordSize>line.size()) {
+	    wordSize=std::string::npos;
+	  }
+	  substr=line.substr(wordBegin,wordSize-wordBegin);
+	  strncpy(mTemperature, substr.c_str(),sizeof(mTemperature));
+	  if (mFahrenheit) {
+	    strncpy(mTemperatureUnit," °F",sizeof(mTemperatureUnit));
+	  } else {
+	    snprintf(mTemperature,sizeof(mTemperature), "%d", (int)rint((atoi(substr.c_str()) - 32) / 1.8));
+	    strncpy(mTemperatureUnit," °C",sizeof(mTemperatureUnit));
+	  }
       }
    }
+    update();
+    return true;
+}
 
-   cerr << APPNAME << ": could not fetch temperature (unknown file format)" << endl;
-   return false;
+void Temperature::update()
+{
+    _dockapp->refresh();
+    int  dtmp=0;
+    int  utmp=0;
+    bool dOdd=false;
+    bool uOdd=false;
+    if(mShowWind) {
+	int pos=POS;
+	if(dOdd) {
+	    pos+=dtmp;
+	    dOdd=false;
+	} else {
+	    pos+=dtmp;
+	    dtmp+=10;
+	    dOdd=true;
+	}
+	_dockapp->drawComposedString(pos, mWind, strlen(mWind),_mediumFont
+					,mWindUnit,strlen(mWindUnit),_smallFont);
+    }
+    if(mShowPressure) {
+	if(!utmp && dtmp) {
+	    utmp=10;
+	}
+	int pos=POS;
+	if(uOdd) {
+	    pos-=utmp;
+	    uOdd=false;
+	} else {
+	    pos-=utmp;
+	    utmp+=10;
+	    uOdd=true;
+	}
+	_dockapp->drawComposedString(pos,mPressure,strlen(mPressure),_mediumFont
+					,mPressureUnit,strlen(mPressureUnit),_smallFont);
+    }
+    if (mShowTime) {
+	if(utmp && !dtmp) {
+	    dtmp=10;
+	}
+	int pos=POS;
+	if(dOdd) {
+	    pos+=dtmp;
+	    dOdd=false;
+	} else {
+	    pos+=dtmp;
+	    dtmp+=10;
+	    dOdd=true;
+	}
+       if (mTime12HourFormat) {
+	  _dockapp->drawComposedString(pos,mTime,strlen(mTime),_mediumFont
+					,mTimeAMPM,strlen(mTimeAMPM),_smallFont);
+       } else {
+	  _dockapp->drawCenterString(pos,mTime,strlen(mTime),_mediumFont);
+       }
+    }
+    if (mShowTemperatureWindChill && strlen(mTemperatureWindChill)) {
+	snprintf(mTemperatureWindChillAndUnit,sizeof(mTemperatureWindChillAndUnit),"/%s%s",mTemperatureWindChill,mTemperatureUnit);
+    } else {
+	strncpy(mTemperatureWindChillAndUnit,mTemperatureUnit,strlen(mTemperatureUnit)+1);
+    }
+    if(true) {
+	if(!utmp && dtmp) {
+	    utmp=10;
+	}
+	int pos=POS;
+	if(uOdd) {
+	    pos-=utmp;
+	    uOdd=false;
+	} else {
+	    pos-=utmp;
+	    utmp+=10;
+	    uOdd=true;
+	}
+	_dockapp->drawComposedString(pos,mTemperature,strlen(mTemperature),_bigFont
+	    ,mTemperatureWindChillAndUnit,strlen(mTemperatureWindChillAndUnit),_mediumFont);
+    }
 }
 
 void Temperature::run() 
@@ -394,6 +527,21 @@
    if (mShowTime) {
       calcTimeDiff();
    }
+   _smallFont=XftFontOpenName(mDisplay,DefaultScreen(mDisplay),_smallFontString.c_str());
+   if(!_smallFont) {
+      std::cerr << "XftFontOpenName() failed! " << _smallFontString << std::endl;
+      exit(1);
+   }
+   _mediumFont=XftFontOpenName(mDisplay,DefaultScreen(mDisplay),_mediumFontString.c_str());
+   if(!_mediumFont) {
+      std::cerr << "XftFontOpenName() failed! " << _mediumFontString << std::endl;
+      exit(1);
+   }
+   _bigFont=XftFontOpenName(mDisplay,DefaultScreen(mDisplay),_bigFontString.c_str());
+   if(!_bigFont) {
+      std::cerr << "XftFontOpenName() failed! " << _bigFontString << std::endl;
+      exit(1);
+   }
 
    int counter = 0;
    while(1) {
@@ -401,7 +549,7 @@
          char tmpFile[sizeof(TMP_FILE)] = TMP_FILE;
          int fd = mkstemp(tmpFile);
          if (fd == -1) {
-            cerr << APPNAME << ": could not create temporary file " << tmpFile << ": " << strerror(errno) << endl;
+            std::cerr << APPNAME << ": could not create temporary file " << tmpFile << ": " << strerror(errno) << std::endl;
             exit(1);
          }
          close(fd);
@@ -409,31 +557,31 @@
          counter = UPDATE_INTERVAL;
          childStatus = ChildRunning;
          signal(SIGCHLD, catchChildExit);
-         showLed(true);
+         _dockapp->showLED(true);
          int pid = fork();
          if (pid == 0) {
             const char* verbose = (mVerbose ? "--verbose" : "--quiet");
             char* URL = new char[strlen(METAR_URL) + strlen(mStationId) + 1];
             sprintf(URL, METAR_URL, mStationId);
-            execlp("wget", "wget", "--cache=off", "--tries=0", verbose, "-O", tmpFile, URL, 0);
-            cerr << APPNAME << ": could not fetch temperature (wget not found in $PATH)" << endl;
+            execlp("/usr/bin/wget", "/usr/bin/wget", "--cache=off", "--tries=0", verbose, "-O", tmpFile, URL, 0);
+            std::cerr << APPNAME << ": could not fetch temperature (wget not found in $PATH)" << std::endl;
             remove(tmpFile);
             exit(0);
          } else if (pid == -1) {
-            cerr << APPNAME << ": could not fetch temperature (fork() failed)" << endl;
+            std::cerr << APPNAME << ": could not fetch temperature (fork() failed)" << std::endl;
          } else {
             bool toggle = true;
             while (childStatus == ChildRunning) {
-               showLed(toggle);
+               _dockapp->showLED(toggle);
                toggle ^= true;
                sleep(1);
             }
-            showLed(true);
+            _dockapp->showLED(true);
             if (childStatus == ChildDone) {
-               ifstream file(tmpFile);
+               std::ifstream file(tmpFile);
                if (file) {
                   if (updateTemperture(file)) {
-                     showLed(false);
+                     _dockapp->showLED(false);
                   }
                   file.close();
                }
@@ -441,8 +589,23 @@
             remove(tmpFile);
          }
       } else {
+	    while(XPending(mDisplay)) {
+		XEvent event;
+		XNextEvent(mDisplay,&event);
+		switch(event.type) {
+		    case ButtonPress:
+			std::cout << "button pressed" << std::endl;
+			break;
+		    case ButtonRelease:
+			std::cout << "button released" << std::endl;
+			break;
+		    case Expose:
+			update();
+			break;
+		}
+	    }
+	    usleep(100000);
          counter--;
-         sleep(1);
          XSync(mDisplay, False);
       }
    }
--- Temperature.h	2002-04-06 01:44:17.000000000 +0200
+++ Temperature.h	2006-02-24 20:56:33.000000000 +0100
@@ -2,6 +2,7 @@
 //  Temperature.app
 // 
 //  Copyright (c) 2000-2002 Per Liden
+//  Copyright (c) 2004 Sven Schaepe
 // 
 //  This program is free software; you can redistribute it and/or modify
 //  it under the terms of the GNU General Public License as published by
@@ -22,22 +23,22 @@
 #ifndef _TEMPERATURE_H_
 #define _TEMPERATURE_H_
 
-#include <fstream.h>
 #include <X11/Xlib.h>
+#include <fstream>
+#include <string>
+#include "dockapp.h"
 
 #define APPNAME                 "Temperature.app"
-#define VERSION                 "1.4"
+#define VERSION                 "1.4.5"
 #define INSTANCENAME            "temperature_app"
 #define CLASSNAME               "Temperature_app"
 #define METAR_URL               "http://weather.noaa.gov/pub/data/observations/metar/decoded/%s.TXT"
 #define UPDATE_INTERVAL         900
-#define TIME_POS                22
-#define TEMP_POS                35
-#define TEMP_WITH_TIME_POS      42
-#define TIME_FONT               "-*-helvetica-medium-r-*-*-10-*-*-*-*-*-*-*"
-#define AMPM_FONT               "-*-helvetica-medium-r-*-*-8-*-*-*-*-*-*-*"
-#define TEMP_FONT               "-*-helvetica-medium-r-*-*-18-*-*-*-*-*-*-*"
-#define UNIT_FONT               "-*-helvetica-medium-r-*-*-12-*-*-*-*-*-*-*"
+#define POS                	40
+#define TIME_FONT               "-*-fixed-medium-r-*-*-10-*-*-*-*-*-*-*"
+#define AMPM_FONT               "-*-fixed-medium-r-*-*-8-*-*-*-*-*-*-*"
+#define TEMP_FONT               "-*-fixed-bold-r-*-*-18-*-*-*-*-*-*-*"
+#define UNIT_FONT               "-*-fixed-medium-r-*-*-12-*-*-*-*-*-*-*"
 #define LED_X                   57
 #define LED_Y                   59
 #define TMP_FILE                "/tmp/temperature.app-XXXXXX"
@@ -53,7 +54,7 @@
 {
 public:
    Temperature(int argc, char** argv);
-   ~Temperature() {};
+   ~Temperature();
    void run();
 
 private:
@@ -63,8 +64,9 @@
    void showErrorLed(bool show);
    void calcTimeDiff();
    void setTime(char* utcTime);
-   bool updateTemperture(ifstream& file);
-   void showLed(bool show);
+   bool updateTemperture(std::ifstream& file);
+   void update();
+   std::string windRose(int angle);
 
    Display*  mDisplay;
    Window    mRoot;
@@ -73,14 +75,32 @@
    Window    mStatusLed;
    char*     mInstanceName;
    char*     mStationId;
+   char      mWind[10];
+   char      mWindUnit[5];
+   char      mPressure[6];
+   char      mPressureUnit[8];
    char      mTemperature[5];
+   char      mTemperatureWindChill[5];
+   char      mTemperatureUnit[4]; // because windchill
+   char      mTemperatureWindChillAndUnit[10];
    char      mTime[6];
    char*     mTimeAMPM;
    double    mTimeDiff;
    bool      mFahrenheit;
+   bool      mMPH;
    bool      mShowTime;
+   bool      mShowPressure;
+   bool      mShowWind;
+   bool      mShowTemperatureWindChill;
    bool      mTime12HourFormat;
    bool      mVerbose;
+   Dockapp   *_dockapp;
+   XftFont   *_bigFont;
+   XftFont   *_mediumFont;
+   XftFont   *_smallFont;
+   std::string	_bigFontString;
+   std::string	_mediumFontString;
+   std::string	_smallFontString;
 };
 
 #endif
--- Xpm.cc	2002-04-06 01:44:36.000000000 +0200
+++ Xpm.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,155 +0,0 @@
-//
-//  Temperature.app
-// 
-//  Copyright (c) 2000-2002 Per Liden
-// 
-//  This program is free software; you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation; either version 2 of the License, or
-//  (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, 
-//  USA.
-//
-
-#include <X11/Xlib.h>
-#include <X11/xpm.h>
-#include <X11/extensions/shape.h>
-#include <iostream.h>
-#include <stdlib.h>
-#include <string.h>
-#include "Temperature.h"
-#include "Xpm.h"
-
-Xpm::Xpm(Display* display, Window root, char** data) 
-{
-   int error;
-
-   mDisplay = display;
-
-   mAttributes.valuemask = 0;
-   error = XpmCreatePixmapFromData(mDisplay, root, data, &mImage, &mMask, &mAttributes);
-
-   switch (error) {
-   case XpmColorError:
-      cerr << APPNAME << ": xpm image loaded but did not get all colors needed" << endl;
-      break;
-
-   case XpmColorFailed:
-      cerr << APPNAME << ": could not load xpm image (not enough colors available)" << endl;
-      exit(0);
-      break;
-
-   case XpmNoMemory:
-      cerr << APPNAME << ": could not load xpm image (not enough memory available)" << endl;
-      exit(0);
-      break;
-
-   case XpmOpenFailed:
-   case XpmFileInvalid:
-      cerr << APPNAME << ": could not load xpm image (image broken or corrupt)" << endl;
-      exit(0);
-      break;
-
-   case XpmSuccess:
-   default:
-      // Image loaded ok
-      break;
-   }
-}
-
-Xpm::~Xpm() 
-{
-   if (mImage) {
-      XFreePixmap(mDisplay, mImage);
-   }
-
-   if (mMask) {
-      XFreePixmap(mDisplay, mMask);
-   }
-}
-
-void Xpm::setWindowPixmap(Window win) 
-{
-   XResizeWindow(mDisplay, win, mAttributes.width, mAttributes.height);
-   XSetWindowBackgroundPixmap(mDisplay, win, mImage);
-   XClearWindow(mDisplay, win);
-}
-
-void Xpm::setWindowPixmapShaped(Window win) 
-{
-   XResizeWindow(mDisplay, win, mAttributes.width, mAttributes.height);
-   XSetWindowBackgroundPixmap(mDisplay, win, mImage);
-   XShapeCombineMask(mDisplay, win, ShapeBounding, 0, 0, mMask, ShapeSet);
-   XClearWindow(mDisplay, win);
-}
-
-void Xpm::drawString(int pos, char* font, char* str)
-{
-   XFontStruct* fontStruct;
-   GC           gc;
-   XGCValues    gcv;
-
-   if ((fontStruct = XLoadQueryFont(mDisplay, font)) == 0) {
-      cerr << APPNAME << ": could not load font '" << font << "'" << endl;
-      exit(0);
-   }
-   
-   gcv.foreground = WhitePixel(mDisplay, DefaultScreen(mDisplay));
-   gc = XCreateGC(mDisplay, mImage, GCForeground, &gcv);
-
-   int strLength = strlen(str);
-   int strWidth = XTextWidth(fontStruct, str, strLength);
-   
-   int x = (64 / 2) - (strWidth / 2);
-   XSetFont(mDisplay, gc, fontStruct->fid);
-   XDrawString(mDisplay, mImage, gc, x, pos, str, strLength);
-
-   XFreeGC(mDisplay, gc);
-   XFreeFont(mDisplay, fontStruct);
-}
-
-void Xpm::drawComposedString(int pos, char* font1, char* str1, char* font2, char* str2)
-{
-   XFontStruct* fontStruct1;
-   XFontStruct* fontStruct2;
-   GC           gc;
-   XGCValues    gcv;
-
-   if ((fontStruct1 = XLoadQueryFont(mDisplay, font1)) == 0) {
-      cerr << APPNAME << ": could not load font '" << font1 << "'" << endl;
-      exit(0);
-   }
-
-   if ((fontStruct2 = XLoadQueryFont(mDisplay, font2)) == 0) {
-      cerr << APPNAME << ": could not load font '" << font2 << "'" << endl;
-      exit(0);
-   }
-   
-   gcv.foreground = WhitePixel(mDisplay, DefaultScreen(mDisplay));
-   gc = XCreateGC(mDisplay, mImage, GCForeground, &gcv);
-
-   int str1Length = strlen(str1);
-   int str1Width = XTextWidth(fontStruct1, str1, str1Length);
-   int str2Length = strlen(str2);
-   int str2Width = XTextWidth(fontStruct2, str2, str2Length);
-   
-   int x = (64 / 2) - ((str1Width + str2Width) / 2);
-   XSetFont(mDisplay, gc, fontStruct1->fid);
-   XDrawString(mDisplay, mImage, gc, x, pos, str1, str1Length);
-
-   x += str1Width;
-   XSetFont(mDisplay, gc, fontStruct2->fid);
-   XDrawString(mDisplay, mImage, gc, x, pos, str2, str2Length);
-
-   XFreeGC(mDisplay, gc);
-   XFreeFont(mDisplay, fontStruct1);
-   XFreeFont(mDisplay, fontStruct2);
-}
--- Xpm.h	2002-04-06 01:44:30.000000000 +0200
+++ Xpm.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,45 +0,0 @@
-//
-//  Temperature.app
-// 
-//  Copyright (c) 2000-2002 Per Liden
-// 
-//  This program is free software; you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation; either version 2 of the License, or
-//  (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, 
-//  USA.
-//
-
-#ifndef _XPM_H_
-#define _XPM_H_
-
-#include <X11/Xlib.h>
-#include <X11/xpm.h>
-
-class Xpm 
-{
-public:
-   Xpm(Display* display, Window root, char** data);
-   virtual ~Xpm();
-   void setWindowPixmap(Window win);
-   void setWindowPixmapShaped(Window win);
-   void drawString(int pos, char* font, char* str);
-   void drawComposedString(int pos, char* font1, char* str1, char* font2, char* str2);
-
-private:
-   Display*      mDisplay;
-   XpmAttributes mAttributes;
-   Pixmap        mImage;
-   Pixmap        mMask;
-};
-
-#endif
--- dockapp.cc	1970-01-01 01:00:00.000000000 +0100
+++ dockapp.cc	2006-02-24 21:56:50.000000000 +0100
@@ -0,0 +1,201 @@
+//
+//  dockapp.cc
+// 
+//  Copyright (c) 2006 Sven Schaepe
+// 
+//  This program is free software; you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation; either version 2 of the License, or
+//  (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, 
+//  USA.
+//
+
+#include <X11/Xutil.h>
+#include <X11/extensions/shape.h>
+#include <sstream>
+#include <iostream>
+#include "dockapp.h"
+#include "pixmaps/main.xpm"
+
+void 
+Dockapp::flushExpose(Window w)
+{
+    XEvent dummy;
+    XCheckTypedWindowEvent(_display,w,Expose,&dummy);
+}
+void 
+Dockapp::drawWindow()
+{
+    flushExpose(_iconWin);
+    _image->setXpm();
+    XFlush(_display);
+}
+Dockapp::Dockapp()
+{
+    _display=NULL;
+    _image=NULL;
+    _appWin=0;
+    _iconWin=0;
+    _ledWin=0;
+    _xftDraw=NULL;
+    _fontColor=new DockappColor();
+}
+Dockapp::~Dockapp()
+{
+    XFreeGC(_display,_gc);
+    XftColorFree(_display,DefaultVisual(_display,DefaultScreen(_display))
+				,DefaultColormap(_display,DefaultScreen(_display)),&_xftColor);
+    XftDrawDestroy(_xftDraw);
+    delete _fontColor;
+    if(_iconWin) {
+	XDestroyWindow(_display,_iconWin);
+    }
+    if(_appWin) {
+	XDestroyWindow(_display,_appWin);
+    }
+}
+void
+Dockapp::init(Display *display,char *appName)
+{
+    _display=display;
+    _appWin=XCreateSimpleWindow(_display,RootWindow(_display,DefaultScreen(_display)),1,1,64,64,0,0,0);
+    _iconWin=XCreateSimpleWindow(_display,_appWin,0,0,64,64,0,0,0);
+    _ledWin=XCreateSimpleWindow(_display,_iconWin,57,59,3,2,0,0,0);
+
+// Set classhint
+XClassHint classHint;
+classHint.res_name = appName;
+classHint.res_class = "dockapp";
+XSetClassHint(display, _appWin, &classHint);
+
+/*
+    Atom deleteWindow=XInternAtom(display, "WM_DELETE_WINDOW", False);
+    XSetWMProtocols(display,_appWin,&deleteWindow,1);
+    XSetWMProtocols(display,_iconWin,&deleteWindow,1);
+*/
+
+    XSizeHints sizeHints;
+    sizeHints.flags= USPosition;
+    sizeHints.x = 0;
+    sizeHints.y = 0;
+    XSetWMNormalHints(_display,_appWin,&sizeHints);
+
+    XStoreName(_display,_appWin,appName);
+    XSetIconName(_display,_appWin,appName);
+
+    XWMHints wmHints;
+    wmHints.initial_state = WithdrawnState;
+    wmHints.icon_window = _iconWin;
+    wmHints.icon_x = 0;
+    wmHints.icon_y = 0;
+    wmHints.window_group = _appWin;
+    wmHints.flags = StateHint | IconWindowHint | IconPositionHint | WindowGroupHint;
+    XSetWMHints(_display, _appWin, &wmHints);
+
+    XSelectInput(_display,_iconWin,ButtonPressMask|ButtonReleaseMask|ExposureMask);
+    XMapWindow(_display,_appWin);
+    XMapWindow(_display,_iconWin);
+
+    _xftDraw=XftDrawCreate(_display,_iconWin,DefaultVisual(_display,DefaultScreen(_display))
+			    ,DefaultColormap(_display,DefaultScreen(_display)));
+    if(!_xftDraw) {
+	std::cerr << "XftDrawCreate() failed" << std::endl;
+	exit(1);
+    }
+    XRenderColor xRenderColor={_fontColor->_red,_fontColor->_green,_fontColor->_blue,_fontColor->_alpha}; //0xa500,0x9700,0x9700,0xf500
+    XftColorAllocValue(_display,DefaultVisual(_display,DefaultScreen(_display))
+		,DefaultColormap(_display,DefaultScreen(_display)),&xRenderColor,&_xftColor);
+
+    XWindowAttributes attributes;
+    _gcv.foreground = WhitePixel(_display, DefaultScreen(_display));
+    if(XGetWindowAttributes(_display,RootWindow(_display,DefaultScreen(_display)),&attributes)) {
+	XColor xColor;
+	xColor.red=_fontColor->_red;
+	xColor.green=_fontColor->_green;
+	xColor.blue=_fontColor->_blue;
+	if(XAllocColor(_display,attributes.colormap,&xColor)) {
+	    _gcv.foreground =xColor.pixel;
+	}
+    }
+    _gcv.background = BlackPixel(_display, DefaultScreen(_display));
+    _gcv.graphics_exposures = 0;
+    _gc = XCreateGC(_display,RootWindow(_display,DefaultScreen(_display)), GCForeground | GCGraphicsExposures, &_gcv);
+    //_gc=DefaultGC(display,DefaultScreen(display));
+
+    _image=new Xpm(_display,_iconWin,_gc,main_xpm);
+    XSetWindowBackground(_display,_ledWin,0xff0000);
+    drawWindow();
+}
+void
+Dockapp::refresh()
+{   
+    delete _image;
+    _image=new Xpm(_display,_iconWin,_gc,main_xpm);
+    drawWindow();
+}
+void
+Dockapp::showLED(bool red)
+{   
+   if (red) {
+      XMapWindow(_display,_ledWin);
+   } else {
+      XUnmapWindow(_display,_ledWin);
+   }
+   //XSync(_display,False);
+}
+void
+Dockapp::setAttribute(std::string attribute,std::string value)
+{   
+    if(attribute=="font") {
+    } else if(attribute=="xx") {
+    } else{
+        std::cerr << "Dockapp: no valid attribute: " << attribute << std::endl;
+    }
+}
+void
+Dockapp::setAttribute(std::string attribute,int value)
+{   
+    if(attribute=="color") {
+	_fontColor->set((value>>16)&0xff00,(value>>8)&0xff00,value&0xff00,(value<<8)&0xff00);
+	XRenderColor xRenderColor={_fontColor->_red,_fontColor->_green,_fontColor->_blue,_fontColor->_alpha}; //0xa500,0x9700,0x9700,0xf500
+	XftColorAllocValue(_display,DefaultVisual(_display,DefaultScreen(_display))
+		,DefaultColormap(_display,DefaultScreen(_display)),&xRenderColor,&_xftColor);
+    } else if(attribute=="xx") {
+    } else{
+        std::cerr << "Dockapp: no valid attribute: " << attribute << std::endl;
+    }
+}
+void
+Dockapp::drawComposedString(int y,char *s,int sLen,XftFont *xftFont,char *unit,int unitLen,XftFont *xftFont1) 
+{
+    XGlyphInfo info;
+    XftTextExtents8(_display,xftFont,(FcChar8*)s,sLen,&info);
+    XGlyphInfo info1;
+    XftTextExtents8(_display,xftFont1,(FcChar8*)unit,unitLen,&info1);
+    int x=32-(((info1.xOff)+(info.xOff)+1)/2);
+    drawString(x,y,s,sLen,xftFont);
+    drawString(x+info.xOff+1,y,unit,unitLen,xftFont1);
+}
+void 
+Dockapp::drawCenterString(int y,char *s,int len,XftFont *xftFont) 
+{
+    XGlyphInfo info;
+    XftTextExtents8(_display,xftFont,(FcChar8*)s,len,&info);
+    drawString(32-((info.xOff+1)/2),y,s,len,xftFont);
+}
+void 
+Dockapp::drawString(int x,int y,char *s,int len,XftFont *xftFont) 
+{
+    XGlyphInfo info;
+    XftTextExtents8(_display,xftFont,(FcChar8*)s,len,&info);
+    XftDrawString8(_xftDraw,&_xftColor,xftFont,x,y,(FcChar8*)s,len);
+}
--- dockapp.h	1970-01-01 01:00:00.000000000 +0100
+++ dockapp.h	2006-02-24 21:58:32.000000000 +0100
@@ -0,0 +1,79 @@
+//
+//  dockapp.h
+// 
+//  Copyright (c) 2006 Sven Schaepe
+// 
+//  This program is free software; you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation; either version 2 of the License, or
+//  (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, 
+//  USA.
+//
+
+#ifndef _WM_DOCKAPP_H_
+#define _WM_DOCKAPP_H_
+
+#include <X11/Xft/Xft.h>
+#include <X11/Xlib.h>
+#include <string>
+#include "xpm.h"
+
+class Dockapp
+{
+    private:
+    class DockappColor 
+    {
+	public:
+	unsigned short _red;
+	unsigned short _green;
+	unsigned short _blue;
+	unsigned short _alpha;
+	DockappColor(unsigned short r=0xff00,unsigned short g=0xff00,unsigned short b=0xff00,unsigned short a=0x7f00)
+	    :_red(r),_green(g),_blue(b),_alpha(a) {}
+	void set(unsigned short r,unsigned short g,unsigned short b,unsigned short a) 
+	{
+	    _red=r;
+	    _green=g;
+	    _blue=b;
+	    _alpha=a;
+	}
+    };
+    Display*	_display;
+    Window	_appWin;
+    Window	_iconWin;
+    Window	_ledWin;
+    Xpm*	_image;
+    GC       	_gc;
+    XGCValues	_gcv;
+    DockappColor *_fontColor;
+
+    XftDraw*	_xftDraw;
+    XftColor 	_xftColor;
+
+    protected:
+    virtual void flushExpose(Window w);
+    virtual void drawWindow();
+
+    public:
+    Dockapp();
+    virtual ~Dockapp();
+    virtual void init(Display* display,char *appName);
+    virtual void refresh();
+    virtual void setAttribute(std::string attribute,std::string value);
+    virtual void setAttribute(std::string attribute,int value);
+    virtual void showLED(bool red);
+    virtual void drawString(int x,int y,char *s,int len,XftFont *xftFont);
+    virtual void drawCenterString(int y,char *s,int len,XftFont *xftFont);
+    virtual void drawComposedString(int y,char *s,int sLen,XftFont *xftFont,char *unit,int unitLen,XftFont *xftFont1);
+};
+
+#endif
--- xpm.cc	1970-01-01 01:00:00.000000000 +0100
+++ xpm.cc	2006-02-24 21:57:53.000000000 +0100
@@ -0,0 +1,63 @@
+//
+//  xpm.cc
+// 
+//  Copyright (c) 2006 Sven Schaepe
+// 
+//  This program is free software; you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation; either version 2 of the License, or
+//  (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, 
+//  USA.
+//
+
+#include <X11/Xlib.h>
+#include <X11/xpm.h>
+#include <X11/extensions/shape.h>
+#include <iostream>
+#include <cstdlib>
+#include <cstring>
+#include "xpm.h"
+
+using namespace std;
+
+Xpm::Xpm(Display* display,Window win,GC& gc,char* data[])
+{
+    _display = display;
+    _gc=gc;
+    _win=win;
+    _attributes.valuemask = 0;
+    if(XpmCreatePixmapFromData(_display,win,data,&_image,&_mask,&_attributes)!=XpmSuccess) {
+	std::cerr << "XpmCreatePixmapFromData failed!" << std::endl;
+	exit(1);
+    }
+    XShapeCombineMask(_display,_win,ShapeBounding,0,0,_mask,ShapeSet);
+}
+Xpm::~Xpm() 
+{
+    if(_image) {
+	XFreePixmap(_display,_image);
+    }
+    if(_mask) {
+	XFreePixmap(_display,_mask);
+    }
+}
+void
+Xpm::setXpm()
+{
+    //XCopyArea(_display,_image,_win,_gc,0,0,64,64,0,0);
+    XCopyArea(_display,_image,_win,_gc,0,0,_attributes.width,_attributes.height,0,0);
+}
+void 
+Xpm::drawString(int x,int y,char *string,int len)
+{
+    XDrawString(_display,_image,_gc,x,y,string,len);
+}
--- xpm.h	1970-01-01 01:00:00.000000000 +0100
+++ xpm.h	2006-02-24 21:58:19.000000000 +0100
@@ -0,0 +1,45 @@
+//
+//  xpm.h
+// 
+//  Copyright (c) 2006 Sven Schaepe
+// 
+//  This program is free software; you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation; either version 2 of the License, or
+//  (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, 
+//  USA.
+//
+
+#ifndef _XPM_H_
+#define _XPM_H_
+
+#include <X11/Xlib.h>
+#include <X11/xpm.h>
+
+class Xpm 
+{
+    private:
+    Display*      _display;
+    XpmAttributes _attributes;
+    Pixmap        _image;
+    Pixmap        _mask;
+    GC		  _gc;
+    Window	  _win;
+
+    public:
+    Xpm(Display* display,Window win,GC& gc,char* data[]);
+    virtual ~Xpm();
+    virtual void setXpm();
+    virtual void drawString(int x,int y,char *string,int len);
+};
+
+#endif
