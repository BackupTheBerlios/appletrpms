--- src/afterstep/add_window.c	2007-04-20 17:10:45.000000000 -0500
+++ src/afterstep/add_window.c	2007-05-02 18:39:17.000000000 -0500
@@ -267,7 +267,7 @@
 	/* doing that for any window seems to resolve java sizing bugs */
 	/* this will get called from set_window_wm_state() again just few lines below
 	   which is a bit of a excess, but we don't seem to have much choice */
-    on_window_status_changed( tmp_win, False, True );
+    on_window_status_changed( tmp_win, True );
     if( pending_placement )
     {
         if( !place_aswindow( tmp_win ) )
--- src/afterstep/afterstep.c	2006-09-21 17:56:33.000000000 -0500
+++ src/afterstep/afterstep.c	2007-05-02 18:39:17.000000000 -0500
@@ -741,8 +741,8 @@
     	/* pixmap references */
     	build_xpm_colormap (NULL);
 
-        restack_window_list(INVALID_DESK, True);
-
+		free_scratch_ids_vector();
+		free_scratch_layers_vector();		
         clientprops_cleanup ();
         wmprops_cleanup ();
 
--- libAfterImage/apps/ascompose.c	2005-05-25 09:06:51.000000000 -0500
+++ libAfterImage/apps/ascompose.c	2007-05-02 18:39:15.000000000 -0500
@@ -863,18 +863,28 @@
 #endif
 		}		   
 	}
-	
-	p = create_visual_pixmap( asv, DefaultRootWindow(dpy), im->width, im->height, 0 );
 
-	if( get_flags( asv->glx_support, ASGLX_UseForImageTx ) )
-		done = asimage2drawable_gl( asv, p, im, 0, 0, 0, 0,
-        	   						im->width, im->height, 
-			   						im->width, im->height, 
-									False );
-	
-	if( !done ) 
-		asimage2drawable( asv, p, im, NULL, 0, 0, 0, 0, im->width, im->height, True);
-	
+	if( main_window==DefaultRootWindow(dpy)	)
+	{
+		XImage *xim = create_visual_scratch_ximage( asv, im->width, im->height, DefaultDepth(dpy,DefaultScreen(dpy)) );
+		p = create_visual_pixmap( asv, DefaultRootWindow(dpy), im->width, im->height, 
+							      DefaultDepth(dpy,DefaultScreen(dpy)) );
+		if( subimage2ximage (asv, im, 0, 0, xim)	)
+		{	
+			put_ximage( asv, xim, p, DefaultGC(dpy,DefaultScreen(dpy)), 0, 0, 0, 0, im->width, im->height );	
+		}
+		XDestroyImage( xim );				   
+	}else
+	{
+		p = create_visual_pixmap( asv, DefaultRootWindow(dpy), im->width, im->height, 0 );
+		if( get_flags( asv->glx_support, ASGLX_UseForImageTx ) )
+			done = asimage2drawable_gl( asv, p, im, 0, 0, 0, 0,
+        		   						im->width, im->height, 
+				   						im->width, im->height, 
+										False );
+		if( !done ) 
+			asimage2drawable( asv, p, im, NULL, 0, 0, 0, 0, im->width, im->height, True);
+	}
 	p = set_window_background_and_free( main_window, p );
 	XSync(dpy, False);
 #if 1
--- libAfterBase/ashash.h	2005-08-15 17:20:04.000000000 -0500
+++ libAfterBase/ashash.h	2007-05-02 18:39:14.000000000 -0500
@@ -136,8 +136,8 @@
 
 Bool start_hash_iteration (ASHashTable * hash, ASHashIterator * iterator);
 Bool next_hash_item (ASHashIterator * iterator);
-inline ASHashableValue curr_hash_value (ASHashIterator * iterator);
-inline void *curr_hash_data (ASHashIterator * iterator);
+ASHashableValue curr_hash_value (ASHashIterator * iterator);
+void *curr_hash_data (ASHashIterator * iterator);
 void remove_curr_hash_item (ASHashIterator * iterator, Bool destroy);
 
 
--- libAfterImage/asimage.c	2007-02-22 13:46:13.000000000 -0600
+++ libAfterImage/asimage.c	2007-05-02 18:39:15.000000000 -0500
@@ -113,6 +113,7 @@
 /* ********************************************************************/
 /* initialization routines 											  */
 /* *********************************************************************/
+/* the following is depreciated - we moved to use intrinsics 	!!!!!! */
 /* ************************** MMX **************************************/
 /*inline extern*/
 int mmx_init(void)
--- libAfterImage/asimagexml.c	2007-02-20 10:54:23.000000000 -0600
+++ libAfterImage/asimagexml.c	2007-05-02 18:39:15.000000000 -0500
@@ -2090,7 +2090,6 @@
 		hue_offset = 0 ; 
 		saturation_offset = -99 ;
 	}
-	show_progress("adjusting HSV of the image by [%d,%d,%d] affected hues are %+d-%+d.result = %p", hue_offset, saturation_offset, value_offset, affected_hue-affected_radius, affected_hue+affected_radius, result);
 	if (hue_offset!=0 || saturation_offset != 0 || value_offset != 0 ) 
 	{
 		result = adjust_asimage_hsv(state->asv, imtmp, xorig, yorig, width, height,
@@ -2098,6 +2097,7 @@
 									hue_offset, saturation_offset, value_offset,
 				                    ASA_ASImage, 100, ASIMAGE_QUALITY_TOP);
 	}
+	show_progress("adjusted HSV of the image by [%d,%d,%d] affected hues are %+d-%+d.result = %p", hue_offset, saturation_offset, value_offset, affected_hue-affected_radius, affected_hue+affected_radius, result);
 	return result;
 }
 
--- src/afterstep/asinternals.h	2007-04-20 17:10:46.000000000 -0500
+++ src/afterstep/asinternals.h	2007-05-02 18:39:17.000000000 -0500
@@ -245,6 +245,9 @@
      *          some other window. To do that we substitute focused pointer to new window
      *          right before UngrabEm. In this case focused != ( ungrabbed == hilited )
      */
+
+	ASVector	*stacking_order ; 		/* array of pointers to ASWindow structures */
+	
 }ASWindowList;
 
 /* Mirror Note :
@@ -419,7 +422,14 @@
 void delist_aswindow( ASWindow *t );
 void save_aswindow_list( ASWindowList *list, char *file );
 ASWindow* find_topmost_client( int desk, int root_x, int root_y );
-void restack_window_list( int desk, Bool send_msg_only );
+void free_scratch_layers_vector();
+void free_scratch_ids_vector();
+void update_stacking_order();
+void restack_window_list( int desk);
+void send_stacking_order( int desk );
+void apply_stacking_order( int desk );
+
+
 Bool is_window_obscured (ASWindow * above, ASWindow * below);
 void restack_window( ASWindow *t, Window sibling_window, int stack_mode );
 
@@ -468,7 +478,7 @@
 void on_window_title_changed( ASWindow *asw, Bool update_display );
 void on_window_hints_changed( ASWindow *asw );
 void on_window_opacity_changed( ASWindow *asw );
-void on_window_status_changed( ASWindow *asw, Bool update_display, Bool reconfigured );
+void on_window_status_changed( ASWindow *asw, Bool reconfigured );
 void on_window_hilite_changed( ASWindow *asw, Bool focused );
 void on_window_pressure_changed( ASWindow *asw, int pressed_context );
 
--- libAfterImage/asvisual.c	2006-10-25 18:53:56.000000000 -0500
+++ libAfterImage/asvisual.c	2007-05-02 18:39:15.000000000 -0500
@@ -23,7 +23,7 @@
 #endif
 
 #define LOCAL_DEBUG
-
+/*#define DEBUG_SL2XIMAGE */
 #include <string.h>
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
@@ -54,40 +54,6 @@
 #endif
 
 
-CARD32 color2pixel32bgr(ASVisual *asv, CARD32 encoded_color, unsigned long *pixel);
-CARD32 color2pixel32rgb(ASVisual *asv, CARD32 encoded_color, unsigned long *pixel);
-CARD32 color2pixel24bgr(ASVisual *asv, CARD32 encoded_color, unsigned long *pixel);
-CARD32 color2pixel24rgb(ASVisual *asv, CARD32 encoded_color, unsigned long *pixel);
-CARD32 color2pixel16bgr(ASVisual *asv, CARD32 encoded_color, unsigned long *pixel);
-CARD32 color2pixel16rgb(ASVisual *asv, CARD32 encoded_color, unsigned long *pixel);
-CARD32 color2pixel15bgr(ASVisual *asv, CARD32 encoded_color, unsigned long *pixel);
-CARD32 color2pixel15rgb(ASVisual *asv, CARD32 encoded_color, unsigned long *pixel);
-CARD32 color2pixel_pseudo3bpp( ASVisual *asv, CARD32 encoded_color, unsigned long *pixel );
-CARD32 color2pixel_pseudo6bpp( ASVisual *asv, CARD32 encoded_color, unsigned long *pixel );
-CARD32 color2pixel_pseudo12bpp( ASVisual *asv, CARD32 encoded_color, unsigned long *pixel );
-
-void pixel2color32rgb(ASVisual *asv, unsigned long pixel, CARD32 *red, CARD32 *green, CARD32 *blue);
-void pixel2color32bgr(ASVisual *asv, unsigned long pixel, CARD32 *red, CARD32 *green, CARD32 *blue);
-void pixel2color24rgb(ASVisual *asv, unsigned long pixel, CARD32 *red, CARD32 *green, CARD32 *blue);
-void pixel2color24bgr(ASVisual *asv, unsigned long pixel, CARD32 *red, CARD32 *green, CARD32 *blue);
-void pixel2color16rgb(ASVisual *asv, unsigned long pixel, CARD32 *red, CARD32 *green, CARD32 *blue);
-void pixel2color16bgr(ASVisual *asv, unsigned long pixel, CARD32 *red, CARD32 *green, CARD32 *blue);
-void pixel2color15rgb(ASVisual *asv, unsigned long pixel, CARD32 *red, CARD32 *green, CARD32 *blue);
-void pixel2color15bgr(ASVisual *asv, unsigned long pixel, CARD32 *red, CARD32 *green, CARD32 *blue);
-
-void ximage2scanline32( ASVisual *asv, XImage *xim, ASScanline *sl, int y,  register unsigned char *xim_data );
-void ximage2scanline16( ASVisual *asv, XImage *xim, ASScanline *sl, int y,  register unsigned char *xim_data );
-void ximage2scanline15( ASVisual *asv, XImage *xim, ASScanline *sl, int y,  register unsigned char *xim_data );
-void ximage2scanline_pseudo3bpp( ASVisual *asv, XImage *xim, ASScanline *sl, int y,  register unsigned char *xim_data );
-void ximage2scanline_pseudo6bpp( ASVisual *asv, XImage *xim, ASScanline *sl, int y,  register unsigned char *xim_data );
-void ximage2scanline_pseudo12bpp( ASVisual *asv, XImage *xim, ASScanline *sl, int y,  register unsigned char *xim_data );
-
-void scanline2ximage32( ASVisual *asv, XImage *xim, ASScanline *sl, int y,  register unsigned char *xim_data );
-void scanline2ximage16( ASVisual *asv, XImage *xim, ASScanline *sl, int y,  register unsigned char *xim_data );
-void scanline2ximage15( ASVisual *asv, XImage *xim, ASScanline *sl, int y,  register unsigned char *xim_data );
-void scanline2ximage_pseudo3bpp( ASVisual *asv, XImage *xim, ASScanline *sl, int y,  register unsigned char *xim_data );
-void scanline2ximage_pseudo6bpp( ASVisual *asv, XImage *xim, ASScanline *sl, int y,  register unsigned char *xim_data );
-void scanline2ximage_pseudo12bpp( ASVisual *asv, XImage *xim, ASScanline *sl, int y,  register unsigned char *xim_data );
 
 #ifndef X_DISPLAY_MISSING
 static int  get_shifts (unsigned long mask);
@@ -107,8 +73,8 @@
 {
 	Status sret ;
 	sret = XAllocColor( asv->dpy, cmap, pxcol );
-	show_progress( " XAllocColor in %s:%s():%d has %s -> cmap = %lX, pixel = %d, color = 0x%4.4lX, 0x%4.4lX, 0x%4.4lX",
-				   file, func, line, (sret==0)?"failed":"succeeded", cmap, pxcol->pixel, pxcol->red, pxcol->green, pxcol->blue );
+	show_progress( " XAllocColor in %s:%s():%d has %s -> cmap = %lX, pixel = %lu(%8.8lX), color = 0x%4.4X, 0x%4.4X, 0x%4.4X",
+				   file, func, line, (sret==0)?"failed":"succeeded", cmap, pxcol->pixel, pxcol->pixel, pxcol->red, pxcol->green, pxcol->blue );
 	return sret;
 }
 #define ASV_ALLOC_COLOR(asv,cmap,pxcol)  debug_AllocColor(__FILE__, __FUNCTION__, __LINE__, (asv),(cmap),(pxcol))
@@ -180,7 +146,7 @@
 	/* we want to align data by 8 byte boundary (double)
 	 * to allow for code with less ifs and easier MMX/3Dnow utilization :*/
 	aligned_width = width + (width&0x00000001);
-	sl->buffer = ptr = safemalloc (((aligned_width*4)+4)*sizeof(CARD32));
+	sl->buffer = ptr = safemalloc (((aligned_width*4)+16)*sizeof(CARD32));
 
 	sl->xc1 = sl->red 	= (CARD32*)(((long)ptr>>3)*8);
 	sl->xc2 = sl->green = sl->red   + aligned_width;
@@ -1093,7 +1059,9 @@
 	{	
 		if( root == None ) 
 			root = RootWindow(asv->dpy,DefaultScreen(asv->dpy));
-		p = XCreatePixmap( asv->dpy, root, MAX(width,(unsigned)1), MAX(height,(unsigned)1), (depth==0)?asv->true_depth:depth );
+		if( depth==0 )
+			depth = asv->true_depth ;
+		p = XCreatePixmap( asv->dpy, root, MAX(width,(unsigned)1), MAX(height,(unsigned)1), depth );
 	}
 	return p;
 #else
@@ -1547,7 +1515,10 @@
 #if 0
 	unit = asv->dpy->bitmap_unit;
 #else
-	unit = (asv->true_depth+7)&0x0038;
+	if( depth == 0 ) 
+		unit = (asv->true_depth+7)&0x0038;
+	else
+		unit = (depth+7)&0x0038;
 	if( unit == 24 )
 		unit = 32 ;
 #endif
@@ -1626,7 +1597,10 @@
 #if 0
 	unit = asv->dpy->bitmap_unit;
 #else
-	unit = (asv->true_depth+7)&0x0038;
+	if( depth == 0 )
+		unit = (asv->true_depth+7)&0x0038;
+	else
+		unit = (depth+7)&0x0038;
 	if( unit == 24 )
 		unit = 32 ;
 #endif
--- libAfterImage/asvisual.h	2005-05-25 15:22:07.000000000 -0500
+++ libAfterImage/asvisual.h	2007-05-02 18:39:15.000000000 -0500
@@ -366,6 +366,40 @@
 #endif
 }ASVisual;
 /*******************/
+CARD32 color2pixel32bgr(ASVisual *asv, CARD32 encoded_color, unsigned long *pixel);
+CARD32 color2pixel32rgb(ASVisual *asv, CARD32 encoded_color, unsigned long *pixel);
+CARD32 color2pixel24bgr(ASVisual *asv, CARD32 encoded_color, unsigned long *pixel);
+CARD32 color2pixel24rgb(ASVisual *asv, CARD32 encoded_color, unsigned long *pixel);
+CARD32 color2pixel16bgr(ASVisual *asv, CARD32 encoded_color, unsigned long *pixel);
+CARD32 color2pixel16rgb(ASVisual *asv, CARD32 encoded_color, unsigned long *pixel);
+CARD32 color2pixel15bgr(ASVisual *asv, CARD32 encoded_color, unsigned long *pixel);
+CARD32 color2pixel15rgb(ASVisual *asv, CARD32 encoded_color, unsigned long *pixel);
+CARD32 color2pixel_pseudo3bpp( ASVisual *asv, CARD32 encoded_color, unsigned long *pixel );
+CARD32 color2pixel_pseudo6bpp( ASVisual *asv, CARD32 encoded_color, unsigned long *pixel );
+CARD32 color2pixel_pseudo12bpp( ASVisual *asv, CARD32 encoded_color, unsigned long *pixel );
+
+void pixel2color32rgb(ASVisual *asv, unsigned long pixel, CARD32 *red, CARD32 *green, CARD32 *blue);
+void pixel2color32bgr(ASVisual *asv, unsigned long pixel, CARD32 *red, CARD32 *green, CARD32 *blue);
+void pixel2color24rgb(ASVisual *asv, unsigned long pixel, CARD32 *red, CARD32 *green, CARD32 *blue);
+void pixel2color24bgr(ASVisual *asv, unsigned long pixel, CARD32 *red, CARD32 *green, CARD32 *blue);
+void pixel2color16rgb(ASVisual *asv, unsigned long pixel, CARD32 *red, CARD32 *green, CARD32 *blue);
+void pixel2color16bgr(ASVisual *asv, unsigned long pixel, CARD32 *red, CARD32 *green, CARD32 *blue);
+void pixel2color15rgb(ASVisual *asv, unsigned long pixel, CARD32 *red, CARD32 *green, CARD32 *blue);
+void pixel2color15bgr(ASVisual *asv, unsigned long pixel, CARD32 *red, CARD32 *green, CARD32 *blue);
+
+void ximage2scanline32( ASVisual *asv, XImage *xim, ASScanline *sl, int y,  register unsigned char *xim_data );
+void ximage2scanline16( ASVisual *asv, XImage *xim, ASScanline *sl, int y,  register unsigned char *xim_data );
+void ximage2scanline15( ASVisual *asv, XImage *xim, ASScanline *sl, int y,  register unsigned char *xim_data );
+void ximage2scanline_pseudo3bpp( ASVisual *asv, XImage *xim, ASScanline *sl, int y,  register unsigned char *xim_data );
+void ximage2scanline_pseudo6bpp( ASVisual *asv, XImage *xim, ASScanline *sl, int y,  register unsigned char *xim_data );
+void ximage2scanline_pseudo12bpp( ASVisual *asv, XImage *xim, ASScanline *sl, int y,  register unsigned char *xim_data );
+
+void scanline2ximage32( ASVisual *asv, XImage *xim, ASScanline *sl, int y,  register unsigned char *xim_data );
+void scanline2ximage16( ASVisual *asv, XImage *xim, ASScanline *sl, int y,  register unsigned char *xim_data );
+void scanline2ximage15( ASVisual *asv, XImage *xim, ASScanline *sl, int y,  register unsigned char *xim_data );
+void scanline2ximage_pseudo3bpp( ASVisual *asv, XImage *xim, ASScanline *sl, int y,  register unsigned char *xim_data );
+void scanline2ximage_pseudo6bpp( ASVisual *asv, XImage *xim, ASScanline *sl, int y,  register unsigned char *xim_data );
+void scanline2ximage_pseudo12bpp( ASVisual *asv, XImage *xim, ASScanline *sl, int y,  register unsigned char *xim_data );
 
 /****f* libAfterImage/query_screen_visual()
  * NAME
--- src/afterstep/aswindow.c	2007-04-26 13:38:29.000000000 -0500
+++ src/afterstep/aswindow.c	2007-05-02 18:39:17.000000000 -0500
@@ -64,6 +64,8 @@
 
     list->circulate_list = create_asvector( sizeof(ASWindow*) );
     list->sticky_list = create_asvector( sizeof(ASWindow*) );
+	
+	list->stacking_order = create_asvector( sizeof(ASWindow*) );
 
     Scr.on_dead_window = on_dead_aswindow ;
 
@@ -473,6 +475,8 @@
 			destroy_ashash(&((*list)->bookmarks));
             destroy_asvector(&((*list)->sticky_list));
             destroy_asvector(&((*list)->circulate_list));
+			destroy_asvector(&((*list)->stacking_order));
+			
             free(*list);
             *list = NULL ;
         }
@@ -1024,8 +1028,10 @@
         vector_remove_elem( Scr.Windows->sticky_list, &t );
 
     remove_aswindow_from_layer( t, ASWIN_LAYER(t) );
-
-    untie_aswindow( t );
+	
+	vector_remove_elem( Scr.Windows->stacking_order, &t );
+    
+	untie_aswindow( t );
     discard_bidirelem( Scr.Windows->clients, t );
 	publish_aswindow_list( Scr.Windows, False );	   
 }
@@ -1193,6 +1199,9 @@
 	return NULL ; 
 }
 
+#if 0
+/********************************************************************************************/
+/* old version of code - stacking window IDs instead of pointers to ASWindow */
 static void 
 stack_transients( ASWindow *asw, ASVector *ids, Bool use_frame_ids ) 
 {
@@ -1250,13 +1259,10 @@
     }
 }
 
-
-
 void
 restack_window_list( int desk, Bool send_msg_only )
 {
     static ASVector *ids = NULL ;
-    static ASVector *layers = NULL ;
     unsigned long layers_in, i ;
     ASLayer **l ;
 
@@ -1323,6 +1329,203 @@
     }
 }
 
+#endif
+/********************************************************************************************/
+/********************************************************************************************/
+/********************************************************************************************/
+static void 
+stack_transients( ASWindow *asw, ASVector *list) 
+{
+	int tnum = PVECTOR_USED(asw->transients);
+    LOCAL_DEBUG_OUT( "Client %lX has %d transients", asw->w, tnum );
+	if( tnum > 0 )
+	{/* need to collect all the transients and stick them in front of us in order of creation */
+		ASWindow **sublist = PVECTOR_HEAD(ASWindow*,asw->transients);
+		int curr ;
+		for( curr = 0 ; curr < tnum ; ++curr )
+	        if( !ASWIN_GET_FLAGS(sublist[curr], AS_Dead) )
+			{
+				if( vector_find_data(list, &sublist[curr])  >= PVECTOR_USED(list) )
+				{
+			    	LOCAL_DEBUG_OUT( "Adding transient #%d - %p, w = %lX, frame = %lX", curr, sublist[curr], sublist[curr]->w, sublist[curr]->frame );
+					vector_insert_elem(list, &sublist[curr], 1, NULL, False);
+				}
+			}
+	}
+}
+
+static inline void
+stack_layer_windows( ASLayer *layer, ASVector *list ) 
+{
+    int k;
+    ASWindow **members = PVECTOR_HEAD(ASWindow*,layer->members);
+	
+    LOCAL_DEBUG_OUT( "layer %d, end_k = %d", layer->layer, PVECTOR_USED(layer->members) );
+    for( k = 0 ; k < PVECTOR_USED(layer->members) ; k++ )
+    {
+        ASWindow *asw = members[k] ;
+        if( !ASWIN_GET_FLAGS(asw, AS_Dead) )
+		{
+		    LOCAL_DEBUG_OUT( "Group Lead %p", asw->group_lead );
+			if( asw->group_lead ) 
+			{/* transients for any window in the group go on top of non-transients in the group */
+				ASWindow **sublist = PVECTOR_HEAD(ASWindow*,asw->group_lead->group_members);
+				int curr = PVECTOR_USED(asw->group_lead->group_members);
+			    LOCAL_DEBUG_OUT( "Group members %d", curr );
+				if( asw->group_lead->transients && !ASWIN_GET_FLAGS(asw->group_lead, AS_Dead) )
+					stack_transients( asw->group_lead, list );
+				while( --curr >= 0 ) 
+				{/* most recent group member should have their transients above others */
+					if( !ASWIN_GET_FLAGS(sublist[curr], AS_Dead) && sublist[curr]->transients ) 
+						stack_transients( sublist[curr], list );
+				}
+			}else if( asw->transients )
+				stack_transients( asw, list );
+
+		    LOCAL_DEBUG_OUT( "Adding client - %p, w = %lX, frame = %lX", asw, asw->w, asw->frame );
+			vector_insert_elem(list, &asw, 1, NULL, False);
+		}
+    }
+}
+
+static ASVector *__as_scratch_layers = NULL; 
+
+void
+free_scratch_layers_vector()
+{
+	if( __as_scratch_layers ) 
+		destroy_asvector( &__as_scratch_layers );
+}
+
+ASVector *
+get_scratch_layers_vector()
+{
+    if( __as_scratch_layers == NULL )
+        __as_scratch_layers = create_asvector( sizeof(ASLayer*) );
+	else
+        flush_vector( __as_scratch_layers );
+
+	return __as_scratch_layers;	
+}
+
+
+void
+update_stacking_order()
+{
+   	ASVector *layers = get_scratch_layers_vector() ;
+    unsigned long layers_in, i ;
+    ASLayer **l ;
+	ASVector *list = Scr.Windows->stacking_order ; 
+
+	flush_vector( list );	
+    if( Scr.Windows->clients->count == 0)
+        return;
+
+    if( (layers_in = get_sorted_layers_vector( &layers )) == 0 )
+        return ;
+
+    realloc_vector( list, Scr.Windows->clients->count );
+    l = PVECTOR_HEAD(ASLayer*,layers);
+    for( i = 0 ; i < layers_in ; i++ )
+		stack_layer_windows( l[i], list );
+}
+
+static ASVector *__as_scratch_ids = NULL; 
+
+void
+free_scratch_ids_vector()
+{
+	if( __as_scratch_ids ) 
+		destroy_asvector( &__as_scratch_ids );
+}
+
+ASVector *
+get_scratch_ids_vector()
+{
+    if( __as_scratch_ids == NULL )
+        __as_scratch_ids = create_asvector( sizeof(Window) );
+	else
+        flush_vector( __as_scratch_ids );
+	
+    if( Scr.Windows->clients->count+2 > __as_scratch_ids->allocated )
+        realloc_vector( __as_scratch_ids, Scr.Windows->clients->count+2 );
+	
+	return __as_scratch_ids;	
+}
+
+void 
+send_stacking_order( int desk )
+{
+    if( Scr.Windows->clients->count > 0)
+	{
+		int i ; 
+		ASWindow **stack;
+		int stack_len = PVECTOR_USED(Scr.Windows->stacking_order);
+		ASVector *ids = get_scratch_ids_vector();
+		
+		if( stack_len == 0 ) 
+		{
+			update_stacking_order();	
+			stack_len = PVECTOR_USED(Scr.Windows->stacking_order);
+		}
+		stack = PVECTOR_HEAD(ASWindow*, Scr.Windows->stacking_order);
+		for( i = 0 ; i < stack_len ; ++i )
+			vector_insert_elem(ids, &(stack[i]->w), 1, NULL, False);
+
+	    SendStackingOrder (-1, M_STACKING_ORDER, desk, ids);
+	}
+}
+
+void 
+apply_stacking_order( int desk )
+{
+    if( Scr.Windows->clients->count > 0)
+	{
+		int i ; 
+		ASWindow **stack;
+		int stack_len = PVECTOR_USED(Scr.Windows->stacking_order);
+		ASVector *ids = get_scratch_ids_vector();
+		Window cw = get_desktop_cover_window();
+		int windows_num ; 
+		
+		if( stack_len == 0 ) 
+		{
+			update_stacking_order();	
+			stack_len = PVECTOR_USED(Scr.Windows->stacking_order);
+		}
+
+        if( cw != None )
+			vector_insert_elem(ids, &cw, 1, NULL, True);
+
+		stack = PVECTOR_HEAD(ASWindow*,Scr.Windows->stacking_order);
+		for( i = 0 ; i < stack_len ; ++i )
+			vector_insert_elem(ids, &(stack[i]->frame), 1, NULL, False);
+
+		windows_num = PVECTOR_USED(ids);
+        LOCAL_DEBUG_OUT( "Setting stacking order: windows_num = %d, ", windows_num );
+        if( windows_num > 0 )
+        {
+		    Window  *windows = PVECTOR_HEAD(Window,ids);
+			
+            XRaiseWindow( dpy, windows[0] );
+            if( windows_num > 1 )
+                XRestackWindows( dpy, windows, windows_num );
+            XSync(dpy, False);
+        }
+        raise_scren_panframes (ASDefaultScr);
+        XRaiseWindow(dpy, Scr.ServiceWin);
+	}
+}
+
+void
+restack_window_list( int desk )
+{
+	update_stacking_order();
+	send_stacking_order( desk );
+	publish_aswindow_list( Scr.Windows, True );
+	apply_stacking_order( desk );
+}
+
 /*
  * we better have our own routine for changing window stacking order,
  * instead of simply passing it to X server, whenever client request
@@ -1609,7 +1812,7 @@
     vector_insert_elem( dst_layer->members, &t, 1, sibling, above );
 
     t->last_restack_time = Scr.last_Timestamp ;
-    restack_window_list( ASWIN_DESK(t), False );
+    restack_window_list( ASWIN_DESK(t) );
 }
 
 
--- libAfterImage/blender.c	2005-04-04 11:52:21.000000000 -0500
+++ libAfterImage/blender.c	2007-05-02 18:39:15.000000000 -0500
@@ -25,6 +25,10 @@
 /*#define LOCAL_DEBUG*/
 /*#define DO_CLOCKING*/
 
+#ifdef HAVE_MMX
+#include <mmintrin.h>
+#endif
+
 #include <ctype.h>
 #ifdef _WIN32
 # include "win32/afterbase.h"
@@ -380,6 +384,7 @@
 	while( ++i < max_i )
 	{
 		int a = ta[i] ;
+		int ca ;
 /*fprintf( stderr, "%4.4x%4.4x%4.4x%4.4x+%4.4x%4.4x%4.4x%4.4x ", ba[i], br[i], bg[i], bb[i], ta[i], tr[i], tg[i], tb[i] );*/
 		if( a >= 0x0000FF00 )
 		{
@@ -387,17 +392,42 @@
 			bg[i] = tg[i] ;
 			bb[i] = tb[i] ;
 			ba[i] = 0x0000FF00;
-		}else if( a > 0 )
+		}else if( a > 0x000000FF )
 		{
 			a = (a>>8) ;
-			ba[i] = ((ba[i]*(255-a))>>8)+ta[i] ;
-			if( ba[i] > 0x0000FFFF )
-				ba[i] = 0x0000FFFF ;
-			br[i] = (br[i]*(255-a)+tr[i]*a)>>8 ;
-			bg[i] = (bg[i]*(255-a)+tg[i]*a)>>8 ;
-			bb[i] = (bb[i]*(255-a)+tb[i]*a)>>8 ;
+			ca = 255-a;
+#if 0 /*ndef HAVE_MMX*/
+/* MMX implementaion of alpha-blending below turns out to be 
+   30% slower then the original integer math implementation under it 
+   I'm probably stupid or something.  
+ */
+			__m64	va  = _mm_set_pi16 (ca, a, ca, a);
+			__m64	vd  = _mm_set_pi16 (br[i],tr[i],ba[i],ta[i]);
+
+			/* b=(b*ca + t*a)>>8 */
+			vd = _mm_srli_pi16( vd, 8 );
+			vd = _mm_madd_pi16( va, vd );
+			ba[i] = _mm_cvtsi64_si32( vd );
+			vd = _mm_srli_si64( vd, 32 );
+			br[i] = _mm_cvtsi64_si32( vd );
+			
+			vd = _mm_set_pi16 (bb[i],tb[i],bg[i],tg[i]);
+			vd = _mm_srli_pi16( vd, 8 );
+			vd = _mm_madd_pi16( va, vd );
+			bg[i] = _mm_cvtsi64_si32( vd );
+			vd = _mm_srli_si64( vd, 32 );
+			bb[i] = _mm_cvtsi64_si32( vd );
+			
+#else
+			ba[i] = ((ba[i]*ca)>>8)+ta[i] ;
+			br[i] = (br[i]*ca+tr[i]*a)>>8 ;
+			bg[i] = (bg[i]*ca+tg[i]*a)>>8 ;
+			bb[i] = (bb[i]*ca+tb[i]*a)>>8 ;
+#endif	
 		}
 	}
+	_mm_empty();
+	
 /*	fputc( '\n', stderr );*/
 }
 
--- src/afterstep/configure.c	2007-02-22 11:14:31.000000000 -0600
+++ src/afterstep/configure.c	2007-05-02 18:39:17.000000000 -0500
@@ -1440,7 +1440,7 @@
 		redecorate_window( asw, False );
         if( asw->internal && asw->internal->on_look_feel_changed )
             asw->internal->on_look_feel_changed( asw->internal, &Scr.Feel, &Scr.Look, ASFLAGS_EVERYTHING );
-        on_window_status_changed( asw, True, True );
+        on_window_status_changed( asw, True );
 		set_flags( asw->internal_flags, ASWF_PendingShapeRemoval );
     }
     return True;
--- libAfterImage/configure.in	2007-04-23 16:17:12.000000000 -0500
+++ libAfterImage/configure.in	2007-05-02 18:39:15.000000000 -0500
@@ -172,29 +172,38 @@
 fi
 
 
+MMX_CFLAGS="-mmmx -Winline --param inline-unit-growth=10000 --param large-function-growth=10000"
+have_mmx_intrinsics=no
+
 dnl# Check for MMX :
 if test "x$enable_mmx_optimization" = "xyes"; then
-  AC_MSG_CHECKING(for MMX support)
-  if test -z "`echo $build_cpu 2>&1 | grep i*86 >/dev/null`"; then
-	AC_TRY_RUN([int main() {
-                    int ebx_save;
-                    int mmx_available = 0;
-                    asm ("movl %%ebx, %1\n\t"
-                         "movl \$1, %%eax\n\t"
-                         "cpuid\n\t"
-                         "andl \$0x800000, %%edx\n\t"
-                         "movl %1, %%ebx\n\t"
-                         "movl %%edx, %0\n\t"
-                         : "=m" (mmx_available), "=m" (ebx_save)
-                         : /* no input */
-                         : "eax", "ecx", "edx"
-                        );
-                    return mmx_available != 0 ? 0 : 1;}],
-				[AC_DEFINE(HAVE_MMX,1,[Define if CPU supports MMX instructions]) AC_MSG_RESULT(yes)],AC_MSG_RESULT(no))
-  else
-	  AC_MSG_RESULT(skipped)
-  fi
+  	AC_MSG_CHECKING(for MMX support)
+  
+  	save_CFLAGS=$CFLAGS
+  	CFLAGS="$CFLAGS $MMX_CFLAGS"
+AC_COMPILE_IFELSE([
+#if defined(__GNUC__) && (__GNUC__ < 3 || (__GNUC__ == 3 && __GNUC_MINOR__ < 4))
+#error "Need GCC >= 3.4 for MMX intrinsics"
+#endif
+#include <mmintrin.h>
+int main () {
+    __m64 v = _mm_cvtsi32_si64 (1);
+    __m64 w = _mm_slli_si64 (v, 1);
+	v = _mm_add_pi32 (v, w);  /* paddd */
+    v = _mm_srl_pi32 (v, w);  /* psrld */
+    return _mm_cvtsi64_si32 (v);
+}], have_mmx_intrinsics=yes)
+
+	AC_MSG_RESULT($have_mmx_intrinsics)
+	CFLAGS=$save_CFLAGS
+fi
+
+if test $have_mmx_intrinsics = yes ; then
+	AC_DEFINE(HAVE_MMX,1,[Define if CPU supports MMX instructions])
+else 
+   MMX_CFLAGS=
 fi
+AC_SUBST(MMX_CFLAGS)
 
 dnl# Check for X :
 dnl# check for X, if top level configure script did not do that yet :
--- libAfterImage/configure	2007-04-23 16:17:11.000000000 -0500
+++ libAfterImage/configure	2007-05-02 18:39:15.000000000 -0500
@@ -310,7 +310,7 @@
 # include <unistd.h>
 #endif"
 
-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT LN_S build build_cpu build_vendor build_os host host_cpu host_vendor host_os INSTALL INSTALL_PROGRAM INSTALL_DATA INSTALL_LIB RANLIB RM MV CP MKDIR PERL FIND XARGS LDCONFIG LEX LEXLIB YACC INSTALL_SCRIPT ac_ct_RANLIB CPP X_CFLAGS X_PRE_LIBS X_LIBS X_EXTRA_LIBS EGREP XPM_CFLAGS JPEG_CFLAGS PNG_CFLAGS GIF_CFLAGS TIFF_CFLAGS PKG_CONFIG ac_pt_PKG_CONFIG SVG_CFLAGS SVG_LIBS TTF_INCLUDES JPEG_OBJS ZLIB_OBJS PNG_OBJS UNGIF_OBJS AFTERIMAGE_LIBS_EXTERNAL AFTERBASE_INCS_PATH USE_DEFAULT_AFTERBASE HAVE_AFTERBASE_FLAG AFTERBASE_C have_afterbase AFTERIMAGE_APPS_LIBS AFTERIMAGE_TEST_LIBS AFTERIMAGE_LIB_LIBS afterimage_x_support AFTERIMAGE_LIBS image_format version version_major lib_name lib_file_name with_locale user_ldflags x_libs LIBPROG LIBINSTALL DEFINE_XLOCALE LIBOBJS LTLIBOBJS'
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT LN_S build build_cpu build_vendor build_os host host_cpu host_vendor host_os INSTALL INSTALL_PROGRAM INSTALL_DATA INSTALL_LIB RANLIB RM MV CP MKDIR PERL FIND XARGS LDCONFIG LEX LEXLIB YACC INSTALL_SCRIPT ac_ct_RANLIB MMX_CFLAGS CPP X_CFLAGS X_PRE_LIBS X_LIBS X_EXTRA_LIBS EGREP XPM_CFLAGS JPEG_CFLAGS PNG_CFLAGS GIF_CFLAGS TIFF_CFLAGS PKG_CONFIG ac_pt_PKG_CONFIG SVG_CFLAGS SVG_LIBS TTF_INCLUDES JPEG_OBJS ZLIB_OBJS PNG_OBJS UNGIF_OBJS AFTERIMAGE_LIBS_EXTERNAL AFTERBASE_INCS_PATH USE_DEFAULT_AFTERBASE HAVE_AFTERBASE_FLAG AFTERBASE_C have_afterbase AFTERIMAGE_APPS_LIBS AFTERIMAGE_TEST_LIBS AFTERIMAGE_LIB_LIBS afterimage_x_support AFTERIMAGE_LIBS image_format version version_major lib_name lib_file_name with_locale user_ldflags x_libs LIBPROG LIBINSTALL DEFINE_XLOCALE LIBOBJS LTLIBOBJS'
 ac_subst_files='LIBAFTERIMAGEFILES'
 
 # Initialize some variables set by options.
@@ -3192,73 +3192,75 @@
 fi
 
 
+MMX_CFLAGS="-mmmx -Winline --param inline-unit-growth=10000 --param large-function-growth=10000"
+have_mmx_intrinsics=no
+
 if test "x$enable_mmx_optimization" = "xyes"; then
-  echo "$as_me:$LINENO: checking for MMX support" >&5
+  	echo "$as_me:$LINENO: checking for MMX support" >&5
 echo $ECHO_N "checking for MMX support... $ECHO_C" >&6
-  if test -z "`echo $build_cpu 2>&1 | grep i*86 >/dev/null`"; then
 
-if test "$cross_compiling" = yes; then
-  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
-See \`config.log' for more details." >&5
-echo "$as_me: error: cannot run test program while cross compiling
-See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-int main() {
-                    int ebx_save;
-                    int mmx_available = 0;
-                    asm ("movl %%ebx, %1\n\t"
-                         "movl \$1, %%eax\n\t"
-                         "cpuid\n\t"
-                         "andl \$0x800000, %%edx\n\t"
-                         "movl %1, %%ebx\n\t"
-                         "movl %%edx, %0\n\t"
-                         : "=m" (mmx_available), "=m" (ebx_save)
-                         : /* no input */
-                         : "eax", "ecx", "edx"
-                        );
-                    return mmx_available != 0 ? 0 : 1;}
+  	save_CFLAGS=$CFLAGS
+  	CFLAGS="$CFLAGS $MMX_CFLAGS"
+
+cat >conftest.$ac_ext <<_ACEOF
+
+#if defined(__GNUC__) && (__GNUC__ < 3 || (__GNUC__ == 3 && __GNUC_MINOR__ < 4))
+#error "Need GCC >= 3.4 for MMX intrinsics"
+#endif
+#include <mmintrin.h>
+int main () {
+    __m64 v = _mm_cvtsi32_si64 (1);
+    __m64 w = _mm_slli_si64 (v, 1);
+	v = _mm_add_pi32 (v, w);  /* paddd */
+    v = _mm_srl_pi32 (v, w);  /* psrld */
+    return _mm_cvtsi64_si32 (v);
+}
 _ACEOF
-rm -f conftest$ac_exeext
-if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_MMX 1
-_ACEOF
- echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6
+  have_mmx_intrinsics=yes
 else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
+  echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-( exit $ac_status )
-echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6
 fi
-rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+
+	echo "$as_me:$LINENO: result: $have_mmx_intrinsics" >&5
+echo "${ECHO_T}$have_mmx_intrinsics" >&6
+	CFLAGS=$save_CFLAGS
 fi
-  else
-	  echo "$as_me:$LINENO: result: skipped" >&5
-echo "${ECHO_T}skipped" >&6
-  fi
+
+if test $have_mmx_intrinsics = yes ; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_MMX 1
+_ACEOF
+
+else
+   MMX_CFLAGS=
 fi
 
+
 afterimage_x_support=yes
 if test "x$PATH_XTRA_CHECKED" != "xyes"; then
 	ac_ext=c
@@ -9944,6 +9946,7 @@
 s,@YACC@,$YACC,;t t
 s,@INSTALL_SCRIPT@,$INSTALL_SCRIPT,;t t
 s,@ac_ct_RANLIB@,$ac_ct_RANLIB,;t t
+s,@MMX_CFLAGS@,$MMX_CFLAGS,;t t
 s,@CPP@,$CPP,;t t
 s,@X_CFLAGS@,$X_CFLAGS,;t t
 s,@X_PRE_LIBS@,$X_PRE_LIBS,;t t
--- src/afterstep/functions.c	2007-04-12 11:40:54.000000000 -0500
+++ src/afterstep/functions.c	2007-05-02 18:39:17.000000000 -0500
@@ -1968,12 +1968,12 @@
     {
 		union { void *ptr ; int id; } module_id;
 		module_id.id = module ;
-	SendPacket (module, M_TOGGLE_PAGING, 1, DoHandlePageing);
-	SendPacket (module, M_NEW_DESKVIEWPORT, 3, Scr.Vx, Scr.Vy, Scr.CurrentDesk);
-	iterate_asbidirlist( Scr.Windows->clients, send_aswindow_data_iter_func, module_id.ptr, NULL, False );
-	SendPacket (module, M_END_WINDOWLIST, 0);
-	if( IsValidDesk(Scr.CurrentDesk) )
-	    restack_window_list( Scr.CurrentDesk, True );
+		SendPacket (module, M_TOGGLE_PAGING, 1, DoHandlePageing);
+		SendPacket (module, M_NEW_DESKVIEWPORT, 3, Scr.Vx, Scr.Vy, Scr.CurrentDesk);
+		iterate_asbidirlist( Scr.Windows->clients, send_aswindow_data_iter_func, module_id.ptr, NULL, False );
+		SendPacket (module, M_END_WINDOWLIST, 0);
+		if( IsValidDesk(Scr.CurrentDesk) )
+			send_stacking_order( Scr.CurrentDesk );
     }
 }
 
--- libAfterImage/imencdec.c	2006-02-15 17:13:54.000000000 -0600
+++ libAfterImage/imencdec.c	2007-05-02 18:39:15.000000000 -0500
@@ -30,7 +30,6 @@
 #include "config.h"
 #endif
 
-
 #include <string.h>
 #ifdef DO_CLOCKING
 #if TIME_WITH_SYS_TIME
@@ -54,6 +53,10 @@
 #include <stdarg.h>
 #endif
 
+#ifdef HAVE_MMX
+#include <mmintrin.h>
+#endif
+
 #ifdef _WIN32
 # include "win32/afterbase.h"
 #else
@@ -247,6 +250,15 @@
 #ifdef HAVE_MMX
 		if( asimage_use_mmx )
 		{
+#if 1
+			__m64  *vdst = (__m64*)&(dst[0]);
+			__m64  *vsrc = (__m64*)&(src[0]);
+			len = len>>1;
+			do{
+        		vdst[i] = _mm_srli_pi32(vsrc[i],1);  /* psrld */
+			}while( ++i < len );
+ 			_mm_empty();
+#else
 			double *ddst = (double*)&(dst[0]);
 			double *dsrc = (double*)&(src[0]);
 			len = len>>1;
@@ -260,6 +272,7 @@
 					: "m"  (dsrc[i]) // %1
 	            );
 			}while( ++i < len );
+#endif		
 		}else
 #endif
 			do{
@@ -1290,14 +1303,22 @@
 	register XImage *xim = imout->im->alt.ximage ;
 	if( imout->next_line < xim->height && imout->next_line >= 0 )
 	{
+		unsigned char *dst = (unsigned char*)xim->data+imout->next_line*xim->bytes_per_line ;
 		if( !get_flags(to_store->flags, SCL_DO_RED) )
 			set_component( to_store->red, ARGB32_RED8(to_store->back_color), 0, to_store->width );
 		if( !get_flags(to_store->flags, SCL_DO_GREEN) )
 			set_component( to_store->green, ARGB32_GREEN8(to_store->back_color), 0, to_store->width );
 		if( !get_flags(to_store->flags, SCL_DO_BLUE) )
 			set_component( to_store->blue , ARGB32_BLUE8(to_store->back_color), 0, to_store->width );
-		PUT_SCANLINE(imout->asv, xim,to_store,imout->next_line,
-					 (unsigned char*)xim->data+imout->next_line*xim->bytes_per_line);
+		if( xim->depth == imout->asv->visual_info.depth ) 
+			PUT_SCANLINE(imout->asv, xim,to_store,imout->next_line, dst );
+		else if( xim->depth == 16 ) 
+			scanline2ximage16( imout->asv, xim, to_store,imout->next_line, dst);
+		else if( xim->depth == 24 || xim->depth == 32 ) 
+			scanline2ximage32( imout->asv, xim, to_store,imout->next_line, dst);
+		else if( xim->depth == 15 ) 
+			scanline2ximage15( imout->asv, xim, to_store,imout->next_line, dst);
+		
 
 		if( imout->tiling_step > 0 )
 			tile_ximage_line( imout->im->alt.ximage, imout->next_line,
--- libAfterImage/Makefile.in	2007-04-20 17:10:45.000000000 -0500
+++ libAfterImage/Makefile.in	2007-05-02 18:39:15.000000000 -0500
@@ -69,7 +69,7 @@
 LIBVERMAJOR     = 0
 
 CC		= @CC@
-CCFLAGS         = @CFLAGS@
+CCFLAGS         = @CFLAGS@  @MMX_CFLAGS@
 # -march=pentiumpro -mcpu=pentiumpro
 EXTRA_DEFINES	= @DEFINE_XLOCALE@
 
@@ -352,6 +352,11 @@
 test_asdraw:	test_asdraw.o
 		$(CC) test_asdraw.o $(USER_LD_FLAGS) $(LIBRARIES_TEST) $(EXTRA_LIBRARIES) -o test_asdraw
 
+test_mmx.o:	test_mmx.c
+		$(CC) $(CCFLAGS) $(EXTRA_DEFINES) -DTEST_ASDRAW $(INCLUDES) $(EXTRA_INCLUDES) -c test_mmx.c -o test_mmx.o
+
+test_mmx:	test_mmx.o
+		$(CC) test_mmx.o $(USER_LD_FLAGS) $(LIBRARIES_TEST) $(EXTRA_LIBRARIES) -o test_mmx
 
 
 .c.o:
--- src/afterstep/menus.c	2006-11-13 11:57:20.000000000 -0600
+++ src/afterstep/menus.c	2007-05-02 18:39:17.000000000 -0500
@@ -1758,7 +1758,7 @@
         {
             clear_flags( menu->owner->hints->function_mask, AS_FuncPinMenu);
             redecorate_window( menu->owner, False );
-            on_window_status_changed( menu->owner, True, True );
+            on_window_status_changed( menu->owner, True );
             if( Scr.Windows->hilited == menu->owner )
                 on_window_hilite_changed (menu->owner, True);
         }
--- src/afterstep/pager.c	2007-04-11 08:56:06.000000000 -0500
+++ src/afterstep/pager.c	2007-05-02 18:39:17.000000000 -0500
@@ -191,7 +191,7 @@
         asw->status->viewport_x = Scr.Vx ;
         asw->status->viewport_y = Scr.Vy ;
         if( !ASWIN_GET_FLAGS(asw,AS_Sticky) )
-            on_window_status_changed( asw, True, True );
+            on_window_status_changed( asw, True );
 
         if( ASWIN_GET_FLAGS(asw,AS_Iconic) && get_flags(Scr.Feel.flags, StickyIcons))
         {   /* we must update let all the modules know that icon viewport has changed
@@ -290,7 +290,7 @@
         	quietly_reparent_aswindow( asw, dest, True );
 		}
 		if( dvx != 0 || dvy != 0 )
-			on_window_status_changed( asw, True, True );
+			on_window_status_changed( asw, True );
     }
 	display_progress( False, ".");
     return True;
@@ -440,7 +440,8 @@
 
     	if( IsValidDesk(new_desk) )
 		{
-        	restack_window_list( new_desk, False );
+			apply_stacking_order( new_desk );
+			send_stacking_order( new_desk );
 			FlushAllQueues();              /* yield to modules */
 		}
     	/* Change the look to this desktop's one if it really changed */
@@ -960,7 +961,7 @@
 #ifdef XSHMIMAGE		
 	if(check_shmem_images_enabled())
 	{	
-		data->shm_ximage = create_visual_ximage( Scr.asv, new_im->width, data->lines_per_iteration, 0 );
+		data->shm_ximage = create_visual_ximage( Scr.asv, new_im->width, data->lines_per_iteration, DefaultDepth(dpy,DefaultScreen(dpy)) );
 		data->shmseg = ximage2shmseg(data->shm_ximage) ;
 	}
 #endif	   
@@ -998,13 +999,13 @@
 				y = (data->total_lines - (data->lines_done-data->lines_per_iteration)/2) - lines ;
 												   
 			if( xim == NULL ) 
-				xim = create_visual_scratch_ximage( Scr.asv, im->width, lines, 0 );
+				xim = create_visual_scratch_ximage( Scr.asv, im->width, lines, DefaultDepth(dpy,DefaultScreen(dpy)) );
 			LOCAL_DEBUG_OUT( "making ximage %p, starting at %d, and including %d lines", xim, data->lines_done, lines );
 			if( subimage2ximage (Scr.asv, im, 0, y, xim)	)
 			{	
 				LOCAL_DEBUG_OUT( "done, copying to pixmap at %d, (bytes_per_line = %d)", data->lines_done, xim->bytes_per_line );
 				success = put_ximage( Scr.asv, xim, data->target_pmap, 
-					           			Scr.DrawGC,  0, 0, 0, y, im->width, lines );	
+					           			Scr.RootGC,  0, 0, 0, y, im->width, lines );	
 				LOCAL_DEBUG_OUT( "%s", success?"Success":"Failure" );
 				data->lines_done += lines ;
 				++(data->step);
@@ -1179,7 +1180,7 @@
 			bh->pmap = None ;
 		if( bh->pmap == None )
 		{
-            bh->pmap = create_visual_pixmap( Scr.asv, Scr.Root, new_im->width, new_im->height, 0 );
+            bh->pmap = create_visual_pixmap( Scr.asv, Scr.Root, new_im->width, new_im->height, DefaultDepth(dpy,DefaultScreen(dpy)));
             LOCAL_DEBUG_OUT( "new root pixmap created with id %lX and size %dx%d", bh->pmap, new_im->width, new_im->height );
 		}else
 		{	
@@ -1246,8 +1247,15 @@
 			int pid = -1 ;
 			if( !already_transferring )
 			{	
-       			if( !asimage2drawable( Scr.asv, bh->pmap, new_im, Scr.DrawGC, 0, 0, 0, 0, new_im->width, new_im->height, True) )
+				XImage *xim = create_visual_scratch_ximage( Scr.asv, new_im->width, new_im->height, DefaultDepth(dpy,DefaultScreen(dpy)) );
+				Bool success = False ; 
+				if( subimage2ximage (Scr.asv, new_im, 0, 0, xim)	)
+					success = put_ximage( Scr.asv, xim, bh->pmap, Scr.RootGC, 0, 0, 0, 0, new_im->width, new_im->height );	
+				
+				if( !success ) 
 					show_warning( "failed to draw root background onto pixmap");
+
+				XDestroyImage( xim );				   
         		flush_asimage_cache(new_im);
 			}
 			if( pid <= 0 )
--- libAfterStep/screen.c	2006-10-13 17:14:26.000000000 -0500
+++ libAfterStep/screen.c	2007-05-02 18:39:16.000000000 -0500
@@ -467,7 +467,9 @@
 		scr = ASDefaultScr;
 	
 	gcv.graphics_exposures = False;
-    scr->DrawGC = create_visual_gc( scr->asv, scr->Root, gcm, &gcv );
+
+    scr->RootGC = XCreateGC( dpy, scr->Root, gcm, &gcv );
+	scr->DrawGC = create_visual_gc( scr->asv, scr->Root, gcm, &gcv );
 }
 
 void
@@ -481,6 +483,11 @@
 		XFreeGC(dpy, scr->DrawGC);
 		scr->DrawGC = NULL ;
 	}
+	if( scr->RootGC )
+	{	
+		XFreeGC(dpy, scr->RootGC);
+		scr->RootGC = NULL ;
+	}
 }		
 
 /* Setting up global variables  nonlock_mods, and lock_mods, defined in asapp.c : */
--- libAfterStep/screen.h	2006-04-19 17:28:14.000000000 -0500
+++ libAfterStep/screen.h	2007-05-02 18:39:16.000000000 -0500
@@ -142,6 +142,8 @@
     Cursor  standard_cursors[MAX_CURSORS];
 
     GC DrawGC;          /* GC to draw lines for move and resize */
+    GC RootGC;      /* GC to draw on the root window - 
+						   separate as it may have different color depth */
 
     int xinerama_screens_num ;
 	XRectangle *xinerama_screens;
+++ libAfterImage/test_mmx.c	2007-05-02 14:35:21.000000000 -0500
@@ -0,0 +1,157 @@
+/*
+ * Copyright (c) 2000,2001,2004 Sasha Vasko <sasha at aftercode.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+#define LOCAL_DEBUG
+#undef DO_CLOCKING
+#ifndef NO_DEBUG_OUTPUT
+#undef DEBUG_RECTS
+#undef DEBUG_RECTS2
+#endif
+
+#ifdef _WIN32
+#include "win32/config.h"
+#else
+#include "config.h"
+#endif
+
+
+#include <string.h>
+#ifdef DO_CLOCKING
+#if TIME_WITH_SYS_TIME
+# include <sys/time.h>
+# include <time.h>
+#else
+# if HAVE_SYS_TIME_H
+#  include <sys/time.h>
+# else
+#  include <time.h>
+# endif
+#endif
+#endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#ifdef HAVE_STDARG_H
+#include <stdarg.h>
+#endif
+
+#ifdef HAVE_MMX
+#include <mmintrin.h>
+#endif
+
+#ifdef _WIN32
+# include "win32/afterbase.h"
+#else
+# include "afterbase.h"
+#endif
+#include "asvisual.h"
+#include "blender.h"
+#include "asimage.h"
+#include "imencdec.h"
+
+#define TEST_PADDD
+
+#ifdef DO_CLOCKING
+#define MIN_TEST_LEN 10000000
+#define MAX_TEST_LEN 10000001
+#define MAX_REPS 1
+#else
+#define MIN_TEST_LEN 1
+#define MAX_TEST_LEN 100001
+#define MAX_REPS 1
+#endif
+
+static CARD32 rnd32_seed = 345824357;
+
+#define MAX_MY_RND32		0x00ffffffff
+#ifdef WORD64
+#define MY_RND32() \
+(rnd32_seed = ((1664525L*rnd32_seed)&MAX_MY_RND32)+1013904223L)
+#else
+#define MY_RND32() \
+(rnd32_seed = (1664525L*rnd32_seed)+1013904223L)
+#endif
+
+
+int main()
+{
+	int test_len ; 
+	CARD32 *test_set1 ;
+	CARD32 *test_set2 ;	
+	CARD32 *control_data ;	
+	int i, reps ; 
+
+	for( test_len = MIN_TEST_LEN ; test_len < MAX_TEST_LEN ; ++test_len ) 
+	{
+		test_set1 = safemalloc( (test_len + (test_len&0x01))* sizeof(CARD32) );	
+		test_set2 = safemalloc( (test_len + (test_len&0x01))* sizeof(CARD32) );
+		control_data = safemalloc( (test_len + (test_len&0x01))* sizeof(CARD32) );			
+		for( i = 0 ; i < test_len ; ++i ) 
+		{
+			test_set1[i] = MY_RND32()& 0x00FFFFFF ;
+			test_set2[i] = MY_RND32()& 0x00FFFFFF ;
+		}
+		{
+			START_TIME(int_math);
+			for( reps = 0 ; reps < MAX_REPS ; ++reps ) 
+			{
+				for( i = 0 ; i < test_len ; ++i ) 
+				{
+#ifdef TEST_PADDD				
+					control_data[i] = test_set1[i] + test_set2[i] ; 
+#else
+					control_data[i] = test_set2[i] >> 1 ; 
+#endif
+				}		
+			}
+			SHOW_TIME("Standard int math : ", int_math);
+		}
+		{
+			START_TIME(mmx_math);
+			for( reps = 0 ; reps < MAX_REPS ; ++reps ) 
+			{
+				int len = test_len + (test_len&0x00000001); 
+				__m64  *vdst = (__m64*)&(test_set1[0]);
+				__m64  *vinc = (__m64*)&(test_set2[0]);
+				__m64  *vsrc = (__m64*)&(test_set2[0]);
+				len = len>>1;
+				i = 0 ; 
+				do{
+#ifdef TEST_PADDD				
+					vdst[i] = _mm_add_pi32(vdst[i],vinc[i]);  /* paddd */
+#else
+					vdst[i] = _mm_srli_pi32(vsrc[i],1);  /* psrld */
+#endif 
+				}while( ++i < len );
+			}
+			SHOW_TIME("MMX int math : ", mmx_math);
+		}
+		for( i = 0 ; i < test_len ; ++i ) 
+			if( control_data[i] != test_set1[i] ) 
+				fprintf( stderr, "test %d: position %d differs - %8.8lX	and %8.8lX, set2 = %8.8lX\n", test_len, i, control_data[i], test_set1[i], test_set2[i] );
+//			else	fprintf( stderr, "test %d: position %d same    - %8.8lX	and %8.8lX\n", test_len, i, control_data[i], test_set1[i] );
+		
+		free( control_data );
+		free( test_set2 );
+		free( test_set1 );
+	}
+}
--- libAfterImage/transform.c	2007-02-14 18:36:30.000000000 -0600
+++ libAfterImage/transform.c	2007-05-02 18:39:15.000000000 -0500
@@ -27,6 +27,7 @@
 #else
 #include "config.h"
 #endif
+//#undef HAVE_MMX
 
 #ifdef DO_CLOCKING
 #if TIME_WITH_SYS_TIME
@@ -51,6 +52,9 @@
 #endif
 #include <math.h>
 
+#ifdef HAVE_MMX
+#include <mmintrin.h>
+#endif
 
 #ifdef _WIN32
 # include "win32/afterbase.h"
@@ -318,11 +322,21 @@
 static inline void
 add_component( CARD32 *src, CARD32 *incr, int *scales, int len )
 {
-	int i = 0;
-
 	len += len&0x01;
+#ifdef HAVE_MMX   
 #if 1
-#ifdef HAVE_MMX
+	if( asimage_use_mmx )
+	{
+		int i = 0;
+		__m64  *vdst = (__m64*)&(src[0]);
+		__m64  *vinc = (__m64*)&(incr[0]);
+		len = len>>1;
+		do{
+			vdst[i] = _mm_add_pi32(vdst[i],vinc[i]);  /* paddd */
+		}while( ++i  < len );
+		_mm_empty();
+	}else
+#else
 	if( asimage_use_mmx )
 	{
 		double *ddst = (double*)&(src[0]);
@@ -343,6 +357,7 @@
 #endif
 	{
 		register int c1, c2;
+		int i = 0;
 		do{
 			c1 = (int)src[i] + (int)incr[i] ;
 			c2 = (int)src[i+1] + (int)incr[i+1] ;
@@ -887,9 +902,6 @@
 	  fprintf( stderr, "\n" );
 	}
 #endif
-#ifdef HAVE_MMX
-	mmx_init();
-#endif
 	if((imout = start_image_output( asv, dst, out_format, QUANT_ERR_BITS, quality )) == NULL )
 	{
         destroy_asimage( &dst );
@@ -903,9 +915,6 @@
 			scale_image_up( imdec, imout, h_ratio, scales_h, scales_v );
 		stop_image_output( &imout );
 	}
-#ifdef HAVE_MMX
-	mmx_off();
-#endif
 	free( scales_h );
 	free( scales_v );
 	stop_image_decoding( &imdec );
@@ -973,9 +982,6 @@
 	  fprintf( stderr, "\n" );
 	}
 #endif
-#ifdef HAVE_MMX
-	mmx_init();
-#endif
 	if((imout = start_image_output( asv, dst, out_format, QUANT_ERR_BITS, quality )) == NULL )
 	{
         destroy_asimage( &dst );
@@ -989,9 +995,6 @@
 			scale_image_up( imdec, imout, h_ratio, scales_h, scales_v );
 		stop_image_output( &imout );
 	}
-#ifdef HAVE_MMX
-	mmx_off();
-#endif
 	free( scales_h );
 	free( scales_v );
 	stop_image_decoding( &imdec );
@@ -1023,9 +1026,6 @@
 
 	dst = create_destination_image( to_width, to_height, out_format, compression_out, src->back_color );
 
-#ifdef HAVE_MMX
-	mmx_init();
-#endif
 	if((imout = start_image_output( asv, dst, out_format, (tint!=0)?8:0, quality)) == NULL )
 	{
 		LOCAL_DEBUG_OUT( "failed to start image output%s", "");
@@ -1058,9 +1058,6 @@
 			}
 		stop_image_output( &imout );
 	}
-#ifdef HAVE_MMX
-	mmx_off();
-#endif
 	stop_image_decoding( &imdec );
 
 	SHOW_TIME("", started);
@@ -1126,9 +1123,6 @@
 	}
 	if( i < count )
 		count = i+1 ;
-#ifdef HAVE_MMX
-	mmx_init();
-#endif
 
 	if(imdecs[0] == NULL || (imout = start_image_output( asv, dst, out_format, QUANT_ERR_BITS, quality)) == NULL )
 	{
@@ -1220,9 +1214,6 @@
 			imout->output_image_scanline( imout, &dst_line, 1);
 		stop_image_output( &imout );
 	}
-#ifdef HAVE_MMX
-	mmx_off();
-#endif
 	for( i = 0 ; i < count ; i++ )
 		if( imdecs[i] != NULL )
 		{
@@ -1551,9 +1542,6 @@
 
 	if( asv == NULL ) 	asv = &__transform_fake_asv ;
 
-#ifdef HAVE_MMX
-	mmx_init();
-#endif
 	if((imout = start_image_output( asv, dst, out_format, 0, quality)) == NULL )
 	{
         destroy_asimage( &dst );
@@ -1644,9 +1632,6 @@
 		free_scanline( &result, True );
 		stop_image_output( &imout );
 	}
-#ifdef HAVE_MMX
-	mmx_off();
-#endif
 	SHOW_TIME("", started);
 	return dst;
 }
@@ -1668,9 +1653,6 @@
 
 	if( asv == NULL ) 	asv = &__transform_fake_asv ;
 
-#ifdef HAVE_MMX
-	mmx_init();
-#endif
 	if((imout = start_image_output( asv, dst, out_format, 0, quality)) == NULL )
 	{
         destroy_asimage( &dst );
@@ -1710,9 +1692,6 @@
 			free_scanline( &result, True );
 		stop_image_output( &imout );
 	}
-#ifdef HAVE_MMX
-	mmx_off();
-#endif
 	SHOW_TIME("", started);
 	return dst;
 }
@@ -1758,9 +1737,6 @@
 		return dst ;
 	}
 
-#ifdef HAVE_MMX
-	mmx_init();
-#endif
 	if((imout = start_image_output( asv, dst, out_format, 0, quality)) == NULL )
 	{
         destroy_asimage( &dst );
@@ -1842,9 +1818,6 @@
 		}
 		stop_image_output( &imout );
 	}
-#ifdef HAVE_MMX
-	mmx_off();
-#endif
 	SHOW_TIME("", started);
 	return dst;
 }
@@ -2106,26 +2079,17 @@
 
 	dst = create_destination_image( src->width, src->height, out_format, compression_out, src->back_color);
 
-#ifdef HAVE_MMX
-	mmx_init();
-#endif
 
 	imout = start_image_output(asv, dst, out_format, 0, quality);
     if (!imout)
     {
         destroy_asimage( &dst );
-#ifdef HAVE_MMX
-		mmx_off();
-#endif
 		return NULL;
 	}
 
 	imdec = start_image_decoding(asv, src, SCL_DO_ALL, 0, 0, dst->width, dst->height, NULL);
 	if (!imdec) {
         destroy_asimage( &dst );
-#ifdef HAVE_MMX
-		mmx_off();
-#endif
 		return NULL;
 	}
 
@@ -2172,10 +2136,6 @@
 
 	free(gauss);
 
-#ifdef HAVE_MMX
-	mmx_off();
-#endif
-
 	return dst;
 }
 
@@ -2223,9 +2183,6 @@
 		return NULL;
 
 	dst = create_destination_image( to_width, to_height, out_format, compression_out, src->back_color);
-#ifdef HAVE_MMX
-	mmx_init();
-#endif
 	set_decoder_shift(imdec,8);
 	if((imout = start_image_output( asv, dst, out_format, 8, quality)) == NULL )
 	{
@@ -2319,9 +2276,6 @@
 		}
 		stop_image_output( &imout );
 	}
-#ifdef HAVE_MMX
-	mmx_off();
-#endif
 	stop_image_decoding( &imdec );
 
 	SHOW_TIME("", started);
@@ -2431,9 +2385,6 @@
 		slice_y_start = (slice_y_end > 0 ) ? slice_y_end-1 : 0 ;
 
 	dst = create_destination_image( to_width, to_height, out_format, compression_out, src->back_color);
-#ifdef HAVE_MMX
-	mmx_init();
-#endif
 	if((imout = start_image_output( asv, dst, out_format, 0, quality)) == NULL )
 	{
         destroy_asimage( &dst );
@@ -2597,9 +2548,6 @@
 		free_scanline( out_buf, False );
 		stop_image_output( &imout );
 	}
-#ifdef HAVE_MMX
-	mmx_off();
-#endif
 	stop_image_decoding( &imdec );
 
 	SHOW_TIME("", started);
--- src/afterstep/winstatus.c	2007-04-24 11:58:09.000000000 -0500
+++ src/afterstep/winstatus.c	2007-05-02 18:39:17.000000000 -0500
@@ -885,7 +885,8 @@
 	if( asw->icon_title )
     {
         if( change_astbar_first_label( asw->icon_title, ASWIN_ICON_NAME(asw), ASWIN_ICON_NAME_ENC(asw) ) )
-            on_icon_changed( asw );
+		    if( ASWIN_GET_FLAGS(asw, AS_Iconic ) )
+	            on_icon_changed( asw );
     }
 }
 
@@ -965,7 +966,7 @@
 		status_changed = True ;
 	
 	if( status_changed) 
-	    on_window_status_changed( asw, False, True );
+	    on_window_status_changed( asw, True );
 
 	if( mystrcmp( old_hints->res_name, hints->res_name ) != 0 || 
 		mystrcmp( old_hints->res_class, hints->res_class ) != 0)
@@ -1081,7 +1082,7 @@
 
 
 void
-on_window_status_changed( ASWindow *asw, Bool update_display, Bool reconfigured )
+on_window_status_changed( ASWindow *asw, Bool reconfigured )
 {
     char *unfocus_mystyle = NULL ;
     char *frame_unfocus_mystyle = NULL ;
@@ -1094,7 +1095,7 @@
 
 /*	get_extwm_state_flags (asw->w, &i); */
 	
-LOCAL_DEBUG_CALLER_OUT( "(%p,%s Update display,%s Reconfigured)", asw, update_display?"":"Don't", reconfigured?"":"Not" );
+LOCAL_DEBUG_CALLER_OUT( "(%p,%s Reconfigured)", asw, reconfigured?"":"Not" );
 LOCAL_DEBUG_OUT( "status geometry = %dx%d%+d%+d", asw->status->width, asw->status->height, asw->status->x, asw->status->y );
     if( ASWIN_GET_FLAGS(asw, AS_Iconic ) )
     {
@@ -1103,7 +1104,7 @@
                             AS_ICON_TITLE_UNFOCUS_MYSTYLE ;
         if( asw->icon_title )
             changed = set_astbar_style( asw->icon_title, BAR_STATE_UNFOCUSED, unfocus_mystyle );
-        if( changed ) /* now we need to update icon title size */
+        if( changed || reconfigured ) /* now we need to update icon title size */
             on_icon_changed( asw );
     }else
     {
@@ -1697,7 +1698,7 @@
         map_canvas_window(asw->icon_canvas, True );
         if( asw->icon_canvas != asw->icon_title_canvas )
             map_canvas_window(asw->icon_title_canvas, True );
-        on_window_status_changed( asw, False, True );
+        on_window_status_changed( asw, True );
 LOCAL_DEBUG_OUT( "updating status to iconic for client %p(\"%s\")", asw, ASWIN_NAME(asw) );
     }else
     {   /* Performing transition IconicState->NormalState  */
@@ -1737,7 +1738,7 @@
                 }
             }
         }
-	    on_window_status_changed( asw, True, False );
+	    on_window_status_changed( asw, False );
     }
 
     if( !get_flags(asw->wm_state_transition, ASWT_FROM_WITHDRAWN ) )
@@ -1901,7 +1902,7 @@
 LOCAL_DEBUG_OUT( "changing window's layer to %d", layer );
         ASWIN_LAYER(asw) = layer ;
         add_aswindow_to_layer( asw, layer );
-        restack_window_list( ASWIN_DESK(asw), False );
+        restack_window_list( ASWIN_DESK(asw));
         ASWIN_SET_FLAGS(asw, AS_Layer);
         set_client_state (asw->w, asw->status);
     }
@@ -2134,7 +2135,7 @@
     if( need_placement )
         place_aswindow( asw );
 
-    on_window_status_changed( asw, True, reconfigured );
+    on_window_status_changed( asw, reconfigured );
     if( get_flags( flags, AS_Sticky))
 		update_window_transparency( asw, False );
 	LOCAL_DEBUG_OUT( "Window is %sticky", ASWIN_GET_FLAGS(asw,AS_Sticky)?"S":"NotS");
