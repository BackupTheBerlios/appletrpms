#!/usr/bin/perl

# for each target
#  * pull source from url to tarball - depends on tarball
#  * build srpm from tarball - depends on tarball, specfile
#  * build rpm from tarball - depends on tarball, specfile
#  * build meta files required - urpmi/apt-get etc
#  * build rpm dist
#  * build srpm dist

use strict;
use Data::Dumper;

our $SOURCES = "SOURCES";
our $SPECS = "SPECS";
our $RPMS = "RPMS";
our $SRPMS = "SRPMS";
our $RPM = "rpmbuild --define='_topdir $ENV{PWD}'";

my $target = shift;

my %map = build_target_map("include/as-apps.inc");
%map = interpolate_map(%map);

runtarget($target);

sub runtarget {
    unless(exists $map{uc $target} or
       $target =~ /^(clean|all|download)/) {
        die "No such target $target";
    }
    
    if($target =~ /^all$/) {
        make_all();
    } elsif (exists $map{uc $target}) {
        make_target($target);
    }
}

sub make_all {
    verbose("\building all");
    for my $t (sort keys %map) {
        make_target($t);
    }
}

sub make_target {
    my $target = shift;
    verbose("\nbuilding $target");
    make_download($target);
    make_srpm($target);
    make_rpm($target);
}

sub gen_syms {
    my $target = shift;
    my $n = $map{uc $target}->{NAME};
    my $v = $map{uc $target}->{VERSION};
    my $t = $map{uc $target}->{TAR};
    my $u = $map{uc $target}->{URL};
    return ($n, $v, $t, $u);
}

sub make_srpm {
    my $target = shift;
    my ($name, $version, $tar, $url) = gen_syms($target); 
    verbose("building srpm for $name");
    my $spec = "$SPECS/$name.spec";
    # need to add timing logic here
    if(check_deps("$SRPMS/$name*.src.rpm", 
                  $spec, "$SOURCES/$tar")) {
        system("$RPM -bs $spec");
    } else {
        verbose("  already latest version");
    }
    verbose("  done");
}

sub make_rpm {
    my $target = shift;
    my ($name, $version, $tar, $url) = gen_syms($target); 
    verbose("building rpm for $name");
    my $spec = "$SPECS/$name.spec";
    if(check_deps("$RPMS/*/$name*rpm", 
                  $spec, "$SOURCES/$tar")) {
        # need to add timing logic here
        system("$RPM -bb $spec");
    } else {
        verbose("  already latest version");
    }
    verbose("  done");
}

sub make_download {
    my $target = shift;
    my $tar = $map{uc $target}->{TAR};
    my $url = $map{uc $target}->{URL};
    verbose("  downloading $tar from $url");
    if(!-e "$SOURCES/$tar") {
        system("wget -O $SOURCES/$tar $url");
        verbose("  done");
    } else {
        verbose("  $SOURCES/$tar already exists");
    }
}

sub interpolate_map {
    my %map = (@_);
    foreach my $key (sort keys %map) { 
        my $name = $key . "_NAME";
        my $version = $key . "_VERSION";
        my $tar = $key . "_TAR";

        $map{$key}->{TAR} =~ s/\$\($name\)/$map{$key}->{NAME}/g;
        $map{$key}->{TAR} =~ s/\$\($version\)/$map{$key}->{VERSION}/g;
        $map{$key}->{URL} =~ s/\$\($tar\)/$map{$key}->{TAR}/g;
        $map{$key}->{URL} =~ s/\$\($version\)/$map{$key}->{VERSION}/g;
        $map{$key}->{URL} =~ s/\$\($name\)/$map{$key}->{NAME}/g;
    }
    verbose("added make interpolation to target map");
    return %map;
}

sub build_target_map {
    my %map = ();
    my @files = @_;
    for my $file (@files) {
        open(IN, "<$file");
        while(<IN>) {
            if(/^\s*(\w+)_NAME\s*\=\s*(\S+)/) {
                $map{$1}->{NAME} = $2;
            }
            if(/^\s*(\w+)_VERSION\s*\=\s*(\S+)/) {
                $map{$1}->{VERSION} = $2;
            }
            if(/^\s*(\w+)_URL\s*\=\s*(\S+)/) {
                $map{$1}->{URL} = $2;
            }
            if(/^\s*(\w+)_TAR\s*\=\s*(\S+)/) {
                $map{$1}->{TAR} = $2;
            }
        }
        close(IN);
    }
    verbose("built target map");
    return %map;
}

sub check_deps {
    my $target = shift;
    my @tmp = @_;
    
    my @targets = glob($target);
    print "Targets: @targets\n";
    
    # glob of an array returns an array of arrays
    my @deps = ();
    for my $t (@tmp) {
        push @deps, glob($t);
    }

    if(!scalar(@targets) or !scalar(@deps)) {
        # we have no idea what is going on so we return fail
        return 1;
    }
    my $mtimet = 2000000000; # pretty close to 2038
    my $mtimed = 0;
    
    # this finds the oldest target
    for my $t (@targets) {
        my $m = (stat($t))[9];
        if($m < $mtimet) {
            $mtimet = $m;
        }
    }

    # this finds the youngest dep
    for my $d (@deps) {
        my $m = (stat($d))[9];
        if($m > $mtimed) {
            $mtimed = $m;
        }
    }
 
    if($mtimed >= $mtimet) {
        # a dep is younger than a target
        return 1;
    } else {
        return 0;
    }
}

sub verbose {
    print STDERR shift, "\n";
}
